import { useMemo, useCallback, useRef, useEffect, useState } from 'react';\nimport { debounce, throttle } from 'lodash';\nimport { \n  startOfMonth, \n  endOfMonth, \n  startOfWeek, \n  endOfWeek, \n  isWithinInterval,\n  format\n} from 'date-fns';\nimport { getRecurringInstancesInRange } from '../utils/recurringTaskUtils';\n\n/**\n * Custom hook for optimizing calendar performance\n */\nexport const useCalendarOptimization = ({\n  tasks = [],\n  currentDate,\n  currentView,\n  filters = {}\n}) => {\n  const [isLoading, setIsLoading] = useState(false);\n  const taskIndexRef = useRef(new Map());\n  const memoizedResultsRef = useRef(new Map());\n  const lastComputeTimeRef = useRef(0);\n\n  // Create task index for fast lookups\n  const taskIndex = useMemo(() => {\n    const index = new Map();\n    \n    tasks.forEach(task => {\n      // Index by ID\n      index.set(task._id || task.id, task);\n      \n      // Index by date for quick date-based queries\n      if (task.due) {\n        const dateKey = format(new Date(task.due), 'yyyy-MM-dd');\n        if (!index.has(`date:${dateKey}`)) {\n          index.set(`date:${dateKey}`, []);\n        }\n        index.get(`date:${dateKey}`).push(task);\n      }\n      \n      // Index by priority\n      const priorityKey = `priority:${task.priority}`;\n      if (!index.has(priorityKey)) {\n        index.set(priorityKey, []);\n      }\n      index.get(priorityKey).push(task);\n      \n      // Index by status\n      const statusKey = `status:${task.status}`;\n      if (!index.has(statusKey)) {\n        index.set(statusKey, []);\n      }\n      index.get(statusKey).push(task);\n      \n      // Index by tags\n      if (task.tags) {\n        task.tags.forEach(tag => {\n          const tagKey = `tag:${tag}`;\n          if (!index.has(tagKey)) {\n            index.set(tagKey, []);\n          }\n          index.get(tagKey).push(task);\n        });\n      }\n    });\n    \n    taskIndexRef.current = index;\n    return index;\n  }, [tasks]);\n\n  // Get date range for current view\n  const getViewDateRange = useCallback((view, date) => {\n    switch (view) {\n      case 'month':\n        return {\n          start: startOfWeek(startOfMonth(date)),\n          end: endOfWeek(endOfMonth(date))\n        };\n      case 'week':\n        return {\n          start: startOfWeek(date),\n          end: endOfWeek(date)\n        };\n      case 'day':\n        return {\n          start: new Date(date.getFullYear(), date.getMonth(), date.getDate()),\n          end: new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59)\n        };\n      case 'agenda':\n        return {\n          start: new Date(),\n          end: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000) // 90 days ahead\n        };\n      default:\n        return {\n          start: startOfMonth(date),\n          end: endOfMonth(date)\n        };\n    }\n  }, []);\n\n  // Optimized task filtering with memoization\n  const getFilteredTasks = useCallback((view, date, appliedFilters) => {\n    const cacheKey = `${view}-${format(date, 'yyyy-MM-dd')}-${JSON.stringify(appliedFilters)}`;\n    \n    // Check cache first\n    if (memoizedResultsRef.current.has(cacheKey)) {\n      return memoizedResultsRef.current.get(cacheKey);\n    }\n    \n    const startTime = performance.now();\n    setIsLoading(true);\n    \n    try {\n      const dateRange = getViewDateRange(view, date);\n      let filteredTasks = [];\n      \n      // Use index for efficient filtering when possible\n      if (Object.keys(appliedFilters).length === 0) {\n        // No filters - get all tasks in date range\n        filteredTasks = tasks.filter(task => {\n          if (!task.due) return view === 'agenda';\n          const taskDate = new Date(task.due);\n          return isWithinInterval(taskDate, dateRange);\n        });\n      } else {\n        // Apply filters using index when possible\n        let candidateTasks = new Set();\n        \n        // Start with most restrictive filter\n        const filterKeys = Object.keys(appliedFilters);\n        let firstFilter = true;\n        \n        filterKeys.forEach(filterType => {\n          const filterValues = appliedFilters[filterType];\n          if (!filterValues || filterValues.length === 0) return;\n          \n          let filterResults = new Set();\n          \n          filterValues.forEach(value => {\n            const indexKey = `${filterType}:${value}`;\n            const indexedTasks = taskIndex.get(indexKey) || [];\n            indexedTasks.forEach(task => filterResults.add(task));\n          });\n          \n          if (firstFilter) {\n            candidateTasks = filterResults;\n            firstFilter = false;\n          } else {\n            // Intersection with previous results\n            candidateTasks = new Set([...candidateTasks].filter(task => filterResults.has(task)));\n          }\n        });\n        \n        // Convert to array and apply date range filter\n        filteredTasks = [...candidateTasks].filter(task => {\n          if (!task.due) return view === 'agenda';\n          const taskDate = new Date(task.due);\n          return isWithinInterval(taskDate, dateRange);\n        });\n      }\n      \n      // Include recurring task instances\n      const recurringInstances = getRecurringInstancesInRange(\n        tasks.filter(task => task.recurring && task.recurring.type !== 'none'),\n        dateRange.start,\n        dateRange.end\n      );\n      \n      // Merge and deduplicate\n      const allTasks = [...filteredTasks, ...recurringInstances];\n      const uniqueTasks = allTasks.filter((task, index, array) => \n        array.findIndex(t => (t._id || t.id) === (task._id || task.id)) === index\n      );\n      \n      // Sort by due date\n      const sortedTasks = uniqueTasks.sort((a, b) => {\n        if (!a.due && !b.due) return 0;\n        if (!a.due) return 1;\n        if (!b.due) return -1;\n        return new Date(a.due) - new Date(b.due);\n      });\n      \n      // Cache result\n      memoizedResultsRef.current.set(cacheKey, sortedTasks);\n      \n      // Limit cache size\n      if (memoizedResultsRef.current.size > 50) {\n        const firstKey = memoizedResultsRef.current.keys().next().value;\n        memoizedResultsRef.current.delete(firstKey);\n      }\n      \n      return sortedTasks;\n    } finally {\n      const endTime = performance.now();\n      lastComputeTimeRef.current = endTime - startTime;\n      setIsLoading(false);\n    }\n  }, [tasks, taskIndex, getViewDateRange]);\n\n  // Debounced version for real-time filtering\n  const debouncedGetFilteredTasks = useMemo(\n    () => debounce(getFilteredTasks, 150),\n    [getFilteredTasks]\n  );\n\n  // Get tasks for current view with memoization\n  const visibleTasks = useMemo(() => {\n    return getFilteredTasks(currentView, currentDate, filters);\n  }, [currentView, currentDate, filters, getFilteredTasks]);\n\n  // Virtual scrolling helper for large task lists\n  const useVirtualScrolling = ({\n    items,\n    itemHeight = 60,\n    containerHeight = 400,\n    overscan = 5\n  }) => {\n    const [scrollTop, setScrollTop] = useState(0);\n    \n    const visibleRange = useMemo(() => {\n      const start = Math.floor(scrollTop / itemHeight);\n      const visibleCount = Math.ceil(containerHeight / itemHeight);\n      const end = Math.min(start + visibleCount + overscan, items.length);\n      \n      return {\n        start: Math.max(0, start - overscan),\n        end,\n        visibleItems: items.slice(Math.max(0, start - overscan), end)\n      };\n    }, [scrollTop, itemHeight, containerHeight, overscan, items]);\n    \n    const handleScroll = useCallback(\n      throttle((event) => {\n        setScrollTop(event.target.scrollTop);\n      }, 16), // ~60fps\n      []\n    );\n    \n    return {\n      visibleRange,\n      handleScroll,\n      totalHeight: items.length * itemHeight,\n      offsetY: visibleRange.start * itemHeight\n    };\n  };\n\n  // Task grouping for efficient rendering\n  const getGroupedTasks = useCallback((tasks, groupBy = 'date') => {\n    const groups = new Map();\n    \n    tasks.forEach(task => {\n      let groupKey;\n      \n      switch (groupBy) {\n        case 'date':\n          groupKey = task.due ? format(new Date(task.due), 'yyyy-MM-dd') : 'no-date';\n          break;\n        case 'priority':\n          groupKey = task.priority || 'no-priority';\n          break;\n        case 'status':\n          groupKey = task.status || 'no-status';\n          break;\n        case 'project':\n          groupKey = task.project?.name || 'no-project';\n          break;\n        default:\n          groupKey = 'all';\n      }\n      \n      if (!groups.has(groupKey)) {\n        groups.set(groupKey, []);\n      }\n      groups.get(groupKey).push(task);\n    });\n    \n    return groups;\n  }, []);\n\n  // Preload tasks for adjacent views\n  const preloadAdjacentViews = useCallback(async (view, date) => {\n    const adjacentDates = [];\n    \n    switch (view) {\n      case 'month':\n        adjacentDates.push(\n          new Date(date.getFullYear(), date.getMonth() - 1, 1),\n          new Date(date.getFullYear(), date.getMonth() + 1, 1)\n        );\n        break;\n      case 'week':\n        adjacentDates.push(\n          new Date(date.getTime() - 7 * 24 * 60 * 60 * 1000),\n          new Date(date.getTime() + 7 * 24 * 60 * 60 * 1000)\n        );\n        break;\n      case 'day':\n        adjacentDates.push(\n          new Date(date.getTime() - 24 * 60 * 60 * 1000),\n          new Date(date.getTime() + 24 * 60 * 60 * 1000)\n        );\n        break;\n    }\n    \n    // Preload in background\n    adjacentDates.forEach(adjDate => {\n      setTimeout(() => {\n        getFilteredTasks(view, adjDate, filters);\n      }, 100);\n    });\n  }, [getFilteredTasks, filters]);\n\n  // Clear cache when tasks change significantly\n  useEffect(() => {\n    memoizedResultsRef.current.clear();\n  }, [tasks.length]);\n\n  // Performance monitoring\n  const getPerformanceMetrics = useCallback(() => {\n    return {\n      lastComputeTime: lastComputeTimeRef.current,\n      cacheSize: memoizedResultsRef.current.size,\n      indexSize: taskIndexRef.current.size,\n      taskCount: tasks.length\n    };\n  }, [tasks.length]);\n\n  return {\n    // Optimized data\n    visibleTasks,\n    taskIndex,\n    isLoading,\n    \n    // Optimization functions\n    getFilteredTasks: debouncedGetFilteredTasks,\n    getGroupedTasks,\n    useVirtualScrolling,\n    preloadAdjacentViews,\n    \n    // Cache management\n    clearCache: () => memoizedResultsRef.current.clear(),\n    \n    // Performance monitoring\n    getPerformanceMetrics\n  };\n};\n\n/**\n * Hook for optimizing calendar grid rendering\n */\nexport const useCalendarGridOptimization = ({\n  tasks,\n  dateRange,\n  cellSize = { width: 150, height: 120 }\n}) => {\n  // Memoize task positioning calculations\n  const taskPositions = useMemo(() => {\n    const positions = new Map();\n    \n    tasks.forEach(task => {\n      if (!task.due) return;\n      \n      const taskDate = new Date(task.due);\n      const dateKey = format(taskDate, 'yyyy-MM-dd');\n      \n      if (!positions.has(dateKey)) {\n        positions.set(dateKey, []);\n      }\n      \n      const dayTasks = positions.get(dateKey);\n      const position = {\n        task,\n        x: 0,\n        y: dayTasks.length * 25, // Stack tasks vertically\n        width: cellSize.width - 8,\n        height: 20,\n        zIndex: dayTasks.length\n      };\n      \n      dayTasks.push(position);\n    });\n    \n    return positions;\n  }, [tasks, cellSize]);\n\n  // Optimize task overlap detection\n  const detectOverlaps = useCallback((dateKey) => {\n    const dayPositions = taskPositions.get(dateKey) || [];\n    \n    // Simple overlap detection - can be enhanced with more sophisticated algorithms\n    return dayPositions.map((position, index) => {\n      const overlaps = dayPositions.slice(0, index).filter(otherPosition => \n        position.y < otherPosition.y + otherPosition.height &&\n        position.y + position.height > otherPosition.y\n      );\n      \n      return {\n        ...position,\n        overlaps: overlaps.length,\n        adjustedWidth: position.width / (overlaps.length + 1)\n      };\n    });\n  }, [taskPositions]);\n\n  return {\n    taskPositions,\n    detectOverlaps\n  };\n};\n\n/**\n * Hook for lazy loading calendar data\n */\nexport const useCalendarLazyLoading = ({\n  loadTasks,\n  currentDate,\n  currentView\n}) => {\n  const [loadedRanges, setLoadedRanges] = useState(new Set());\n  const [isLoading, setIsLoading] = useState(false);\n  const loadingRef = useRef(new Set());\n\n  const getRangeKey = useCallback((view, date) => {\n    switch (view) {\n      case 'month':\n        return `month-${format(date, 'yyyy-MM')}`;\n      case 'week':\n        return `week-${format(startOfWeek(date), 'yyyy-MM-dd')}`;\n      case 'day':\n        return `day-${format(date, 'yyyy-MM-dd')}`;\n      default:\n        return `${view}-${format(date, 'yyyy-MM-dd')}`;\n    }\n  }, []);\n\n  const loadRangeIfNeeded = useCallback(async (view, date) => {\n    const rangeKey = getRangeKey(view, date);\n    \n    if (loadedRanges.has(rangeKey) || loadingRef.current.has(rangeKey)) {\n      return;\n    }\n    \n    loadingRef.current.add(rangeKey);\n    setIsLoading(true);\n    \n    try {\n      const dateRange = {\n        month: () => ({ start: startOfMonth(date), end: endOfMonth(date) }),\n        week: () => ({ start: startOfWeek(date), end: endOfWeek(date) }),\n        day: () => ({ start: date, end: date })\n      }[view]?.() || { start: date, end: date };\n      \n      await loadTasks(dateRange.start, dateRange.end);\n      \n      setLoadedRanges(prev => new Set([...prev, rangeKey]));\n    } catch (error) {\n      console.error('Failed to load tasks for range:', rangeKey, error);\n    } finally {\n      loadingRef.current.delete(rangeKey);\n      setIsLoading(loadingRef.current.size > 0);\n    }\n  }, [getRangeKey, loadedRanges, loadTasks]);\n\n  // Auto-load current view\n  useEffect(() => {\n    loadRangeIfNeeded(currentView, currentDate);\n  }, [currentView, currentDate, loadRangeIfNeeded]);\n\n  return {\n    loadRangeIfNeeded,\n    isLoading,\n    loadedRanges: Array.from(loadedRanges)\n  };\n};\n\nexport default {\n  useCalendarOptimization,\n  useCalendarGridOptimization,\n  useCalendarLazyLoading\n};