import { format, parseISO } from 'date-fns';\nimport { isRecurringTask, getRecurringSummary } from './recurringTaskUtils';\n\n/**\n * Calendar export utilities for generating different file formats\n */\n\n/**\n * Generate iCalendar (.ics) format\n * @param {Array} tasks - Array of tasks to export\n * @param {Object} options - Export options\n * @returns {string} iCalendar content\n */\nexport const generateICalendar = (tasks, options = {}) => {\n  const {\n    calendarName = 'Taskly Calendar',\n    includeRecurring = true,\n    timezone = Intl.DateTimeFormat().resolvedOptions().timeZone\n  } = options;\n\n  let icalContent = [\n    'BEGIN:VCALENDAR',\n    'VERSION:2.0',\n    'PRODID:-//Taskly//Taskly Calendar//EN',\n    `X-WR-CALNAME:${calendarName}`,\n    `X-WR-TIMEZONE:${timezone}`,\n    'CALSCALE:GREGORIAN',\n    'METHOD:PUBLISH'\n  ];\n\n  tasks.forEach(task => {\n    if (!task.due) return;\n\n    const startDate = parseISO(task.due);\n    const endDate = new Date(startDate.getTime() + (task.duration || 60) * 60000); // Default 1 hour\n    \n    // Format dates for iCal (YYYYMMDDTHHMMSSZ)\n    const formatICalDate = (date) => {\n      return format(date, \"yyyyMMdd'T'HHmmss'Z'\");\n    };\n\n    const formatICalDateOnly = (date) => {\n      return format(date, 'yyyyMMdd');\n    };\n\n    // Generate unique ID\n    const uid = `${task._id || task.id}@taskly.app`;\n    \n    // Create timestamp\n    const timestamp = formatICalDate(new Date());\n\n    let event = [\n      'BEGIN:VEVENT',\n      `UID:${uid}`,\n      `DTSTAMP:${timestamp}`,\n      `DTSTART:${formatICalDate(startDate)}`,\n      `DTEND:${formatICalDate(endDate)}`,\n      `SUMMARY:${escapeICalText(task.title)}`,\n      `DESCRIPTION:${escapeICalText(task.description || '')}`,\n      `STATUS:${getICalStatus(task.status)}`,\n      `PRIORITY:${getICalPriority(task.priority)}`\n    ];\n\n    // Add categories (tags)\n    if (task.tags && task.tags.length > 0) {\n      event.push(`CATEGORIES:${task.tags.join(',')}`);\n    }\n\n    // Add location if available\n    if (task.location) {\n      event.push(`LOCATION:${escapeICalText(task.location)}`);\n    }\n\n    // Add recurring rule if task is recurring\n    if (includeRecurring && isRecurringTask(task)) {\n      const rrule = generateRRule(task.recurring);\n      if (rrule) {\n        event.push(`RRULE:${rrule}`);\n      }\n    }\n\n    // Add completion date if completed\n    if (task.status === 'completed' && task.completedAt) {\n      event.push(`COMPLETED:${formatICalDate(parseISO(task.completedAt))}`);\n    }\n\n    event.push('END:VEVENT');\n    icalContent = icalContent.concat(event);\n  });\n\n  icalContent.push('END:VCALENDAR');\n  \n  return icalContent.join('\\r\\n');\n};\n\n/**\n * Generate CSV format\n * @param {Array} tasks - Array of tasks to export\n * @returns {string} CSV content\n */\nexport const generateCSV = (tasks) => {\n  const headers = [\n    'Title',\n    'Description',\n    'Due Date',\n    'Due Time',\n    'Priority',\n    'Status',\n    'Tags',\n    'Project',\n    'Assignee',\n    'Created Date',\n    'Completed Date',\n    'Is Recurring',\n    'Recurring Pattern'\n  ];\n\n  const csvRows = [headers.join(',')];\n\n  tasks.forEach(task => {\n    const row = [\n      escapeCSVField(task.title || ''),\n      escapeCSVField(task.description || ''),\n      task.due ? format(parseISO(task.due), 'yyyy-MM-dd') : '',\n      task.due ? format(parseISO(task.due), 'HH:mm') : '',\n      task.priority || '',\n      task.status || '',\n      task.tags ? task.tags.join('; ') : '',\n      task.project?.name || '',\n      task.assignee?.name || task.assignee?.username || '',\n      task.createdAt ? format(parseISO(task.createdAt), 'yyyy-MM-dd HH:mm') : '',\n      task.completedAt ? format(parseISO(task.completedAt), 'yyyy-MM-dd HH:mm') : '',\n      isRecurringTask(task) ? 'Yes' : 'No',\n      isRecurringTask(task) ? getRecurringSummary(task.recurring) : ''\n    ];\n\n    csvRows.push(row.join(','));\n  });\n\n  return csvRows.join('\\n');\n};\n\n/**\n * Generate JSON format\n * @param {Array} tasks - Array of tasks to export\n * @param {Object} metadata - Export metadata\n * @returns {string} JSON content\n */\nexport const generateJSON = (tasks, metadata = {}) => {\n  const exportData = {\n    metadata: {\n      exportDate: new Date().toISOString(),\n      version: '1.0',\n      source: 'Taskly Calendar',\n      ...metadata\n    },\n    tasks: tasks.map(task => ({\n      id: task._id || task.id,\n      title: task.title,\n      description: task.description,\n      due: task.due,\n      priority: task.priority,\n      status: task.status,\n      tags: task.tags || [],\n      project: task.project ? {\n        id: task.project.id || task.project._id,\n        name: task.project.name\n      } : null,\n      assignee: task.assignee ? {\n        id: task.assignee.id || task.assignee._id,\n        name: task.assignee.name || task.assignee.username,\n        email: task.assignee.email\n      } : null,\n      createdAt: task.createdAt,\n      updatedAt: task.updatedAt,\n      completedAt: task.completedAt,\n      isRecurring: isRecurringTask(task),\n      recurringPattern: isRecurringTask(task) ? task.recurring : null,\n      location: task.location,\n      duration: task.duration,\n      reminders: task.reminders || []\n    }))\n  };\n\n  return JSON.stringify(exportData, null, 2);\n};\n\n/**\n * Generate RRULE string for recurring tasks\n * @param {Object} recurring - Recurring pattern\n * @returns {string} RRULE string\n */\nconst generateRRule = (recurring) => {\n  if (!recurring || recurring.type === 'none') return null;\n\n  let rrule = [];\n\n  // Frequency\n  switch (recurring.type) {\n    case 'daily':\n      rrule.push('FREQ=DAILY');\n      break;\n    case 'weekly':\n      rrule.push('FREQ=WEEKLY');\n      break;\n    case 'monthly':\n      rrule.push('FREQ=MONTHLY');\n      break;\n    case 'yearly':\n      rrule.push('FREQ=YEARLY');\n      break;\n    default:\n      return null;\n  }\n\n  // Interval\n  if (recurring.interval && recurring.interval > 1) {\n    rrule.push(`INTERVAL=${recurring.interval}`);\n  }\n\n  // Days of week (for weekly)\n  if (recurring.type === 'weekly' && recurring.daysOfWeek && recurring.daysOfWeek.length > 0) {\n    const dayMap = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\n    const days = recurring.daysOfWeek.map(day => dayMap[day]).join(',');\n    rrule.push(`BYDAY=${days}`);\n  }\n\n  // Day of month (for monthly)\n  if (recurring.type === 'monthly' && recurring.dayOfMonth) {\n    rrule.push(`BYMONTHDAY=${recurring.dayOfMonth}`);\n  }\n\n  // End condition\n  if (recurring.endType === 'after' && recurring.endAfter) {\n    rrule.push(`COUNT=${recurring.endAfter}`);\n  } else if (recurring.endType === 'on' && recurring.endOn) {\n    const endDate = format(parseISO(recurring.endOn), 'yyyyMMdd');\n    rrule.push(`UNTIL=${endDate}`);\n  }\n\n  return rrule.join(';');\n};\n\n/**\n * Escape text for iCalendar format\n * @param {string} text - Text to escape\n * @returns {string} Escaped text\n */\nconst escapeICalText = (text) => {\n  if (!text) return '';\n  \n  return text\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/;/g, '\\\\;')\n    .replace(/,/g, '\\\\,')\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '')\n    .substring(0, 75); // iCal line length limit\n};\n\n/**\n * Escape field for CSV format\n * @param {string} field - Field to escape\n * @returns {string} Escaped field\n */\nconst escapeCSVField = (field) => {\n  if (!field) return '';\n  \n  const stringField = String(field);\n  \n  // If field contains comma, quote, or newline, wrap in quotes and escape quotes\n  if (stringField.includes(',') || stringField.includes('\"') || stringField.includes('\\n')) {\n    return `\"${stringField.replace(/\"/g, '\"\"')}\"`;\n  }\n  \n  return stringField;\n};\n\n/**\n * Convert task status to iCal status\n * @param {string} status - Task status\n * @returns {string} iCal status\n */\nconst getICalStatus = (status) => {\n  switch (status) {\n    case 'completed':\n      return 'COMPLETED';\n    case 'in-progress':\n      return 'IN-PROCESS';\n    case 'cancelled':\n      return 'CANCELLED';\n    default:\n      return 'NEEDS-ACTION';\n  }\n};\n\n/**\n * Convert task priority to iCal priority\n * @param {string} priority - Task priority\n * @returns {number} iCal priority (1-9)\n */\nconst getICalPriority = (priority) => {\n  switch (priority) {\n    case 'high':\n      return 1;\n    case 'medium':\n      return 5;\n    case 'low':\n      return 9;\n    default:\n      return 0; // Undefined\n  }\n};\n\n/**\n * Import tasks from iCalendar format\n * @param {string} icalContent - iCalendar content\n * @returns {Array} Array of parsed tasks\n */\nexport const importFromICalendar = (icalContent) => {\n  const tasks = [];\n  const lines = icalContent.split(/\\r?\\n/);\n  let currentEvent = null;\n  \n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    \n    if (line === 'BEGIN:VEVENT') {\n      currentEvent = {\n        title: '',\n        description: '',\n        due: null,\n        priority: 'medium',\n        status: 'pending',\n        tags: []\n      };\n    } else if (line === 'END:VEVENT' && currentEvent) {\n      if (currentEvent.title && currentEvent.due) {\n        tasks.push(currentEvent);\n      }\n      currentEvent = null;\n    } else if (currentEvent && line.includes(':')) {\n      const [property, ...valueParts] = line.split(':');\n      const value = valueParts.join(':');\n      \n      switch (property) {\n        case 'SUMMARY':\n          currentEvent.title = unescapeICalText(value);\n          break;\n        case 'DESCRIPTION':\n          currentEvent.description = unescapeICalText(value);\n          break;\n        case 'DTSTART':\n          currentEvent.due = parseICalDate(value);\n          break;\n        case 'PRIORITY':\n          currentEvent.priority = parseICalPriority(value);\n          break;\n        case 'STATUS':\n          currentEvent.status = parseICalStatus(value);\n          break;\n        case 'CATEGORIES':\n          currentEvent.tags = value.split(',').map(tag => tag.trim());\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  \n  return tasks;\n};\n\n/**\n * Import tasks from CSV format\n * @param {string} csvContent - CSV content\n * @returns {Array} Array of parsed tasks\n */\nexport const importFromCSV = (csvContent) => {\n  const lines = csvContent.split('\\n');\n  if (lines.length < 2) return [];\n  \n  const headers = parseCSVLine(lines[0]);\n  const tasks = [];\n  \n  for (let i = 1; i < lines.length; i++) {\n    const values = parseCSVLine(lines[i]);\n    if (values.length === 0) continue;\n    \n    const task = {};\n    \n    headers.forEach((header, index) => {\n      const value = values[index] || '';\n      \n      switch (header.toLowerCase()) {\n        case 'title':\n          task.title = value;\n          break;\n        case 'description':\n          task.description = value;\n          break;\n        case 'due date':\n        case 'due time':\n          if (value && !task.due) {\n            task.due = new Date(value).toISOString();\n          }\n          break;\n        case 'priority':\n          task.priority = value.toLowerCase();\n          break;\n        case 'status':\n          task.status = value.toLowerCase();\n          break;\n        case 'tags':\n          task.tags = value ? value.split(';').map(tag => tag.trim()) : [];\n          break;\n        default:\n          break;\n      }\n    });\n    \n    if (task.title) {\n      tasks.push(task);\n    }\n  }\n  \n  return tasks;\n};\n\n// Helper functions for parsing\nconst unescapeICalText = (text) => {\n  return text\n    .replace(/\\\\n/g, '\\n')\n    .replace(/\\\\,/g, ',')\n    .replace(/\\\\;/g, ';')\n    .replace(/\\\\\\\\/g, '\\\\');\n};\n\nconst parseICalDate = (dateStr) => {\n  // Parse YYYYMMDDTHHMMSSZ format\n  const match = dateStr.match(/(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})Z?/);\n  if (match) {\n    const [, year, month, day, hour, minute, second] = match;\n    return new Date(Date.UTC(\n      parseInt(year),\n      parseInt(month) - 1,\n      parseInt(day),\n      parseInt(hour),\n      parseInt(minute),\n      parseInt(second)\n    )).toISOString();\n  }\n  return null;\n};\n\nconst parseICalPriority = (priority) => {\n  const num = parseInt(priority);\n  if (num >= 1 && num <= 3) return 'high';\n  if (num >= 4 && num <= 6) return 'medium';\n  if (num >= 7 && num <= 9) return 'low';\n  return 'medium';\n};\n\nconst parseICalStatus = (status) => {\n  switch (status) {\n    case 'COMPLETED':\n      return 'completed';\n    case 'IN-PROCESS':\n      return 'in-progress';\n    case 'CANCELLED':\n      return 'cancelled';\n    default:\n      return 'pending';\n  }\n};\n\nconst parseCSVLine = (line) => {\n  const result = [];\n  let current = '';\n  let inQuotes = false;\n  \n  for (let i = 0; i < line.length; i++) {\n    const char = line[i];\n    \n    if (char === '\"') {\n      if (inQuotes && line[i + 1] === '\"') {\n        current += '\"';\n        i++; // Skip next quote\n      } else {\n        inQuotes = !inQuotes;\n      }\n    } else if (char === ',' && !inQuotes) {\n      result.push(current);\n      current = '';\n    } else {\n      current += char;\n    }\n  }\n  \n  result.push(current);\n  return result;\n};\n\nexport default {\n  generateICalendar,\n  generateCSV,\n  generateJSON,\n  importFromICalendar,\n  importFromCSV\n};