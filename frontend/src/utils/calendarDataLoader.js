import { \n  startOfMonth, \n  endOfMonth, \n  startOfWeek, \n  endOfWeek, \n  addMonths, \n  subMonths,\n  format,\n  isWithinInterval\n} from 'date-fns';\n\n/**\n * Calendar data loader with caching, prefetching, and optimization\n */\nclass CalendarDataLoader {\n  constructor(options = {}) {\n    this.cache = new Map();\n    this.loadingPromises = new Map();\n    this.prefetchQueue = [];\n    this.options = {\n      maxCacheSize: 50,\n      prefetchDistance: 2, // months\n      cacheExpiry: 5 * 60 * 1000, // 5 minutes\n      batchSize: 100,\n      ...options\n    };\n    \n    // Start prefetch worker\n    this.startPrefetchWorker();\n  }\n\n  /**\n   * Generate cache key for date range\n   */\n  getCacheKey(startDate, endDate, filters = {}) {\n    const start = format(startDate, 'yyyy-MM-dd');\n    const end = format(endDate, 'yyyy-MM-dd');\n    const filterKey = JSON.stringify(filters);\n    return `${start}_${end}_${filterKey}`;\n  }\n\n  /**\n   * Check if cache entry is valid\n   */\n  isCacheValid(entry) {\n    return entry && (Date.now() - entry.timestamp) < this.options.cacheExpiry;\n  }\n\n  /**\n   * Get data from cache\n   */\n  getFromCache(key) {\n    const entry = this.cache.get(key);\n    if (this.isCacheValid(entry)) {\n      entry.lastAccessed = Date.now();\n      return entry.data;\n    }\n    \n    // Remove expired entry\n    if (entry) {\n      this.cache.delete(key);\n    }\n    \n    return null;\n  }\n\n  /**\n   * Store data in cache\n   */\n  setCache(key, data) {\n    // Implement LRU eviction\n    if (this.cache.size >= this.options.maxCacheSize) {\n      const oldestKey = this.findOldestCacheKey();\n      if (oldestKey) {\n        this.cache.delete(oldestKey);\n      }\n    }\n\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      lastAccessed: Date.now()\n    });\n  }\n\n  /**\n   * Find oldest cache entry for LRU eviction\n   */\n  findOldestCacheKey() {\n    let oldestKey = null;\n    let oldestTime = Date.now();\n\n    for (const [key, entry] of this.cache.entries()) {\n      if (entry.lastAccessed < oldestTime) {\n        oldestTime = entry.lastAccessed;\n        oldestKey = key;\n      }\n    }\n\n    return oldestKey;\n  }\n\n  /**\n   * Load tasks for date range with caching\n   */\n  async loadTasks(startDate, endDate, filters = {}, options = {}) {\n    const { \n      force = false, \n      priority = 'normal',\n      loadTasksFn \n    } = options;\n\n    const cacheKey = this.getCacheKey(startDate, endDate, filters);\n\n    // Check cache first\n    if (!force) {\n      const cachedData = this.getFromCache(cacheKey);\n      if (cachedData) {\n        return cachedData;\n      }\n    }\n\n    // Check if already loading\n    if (this.loadingPromises.has(cacheKey)) {\n      return this.loadingPromises.get(cacheKey);\n    }\n\n    // Create loading promise\n    const loadingPromise = this.performLoad(startDate, endDate, filters, loadTasksFn)\n      .then(data => {\n        this.setCache(cacheKey, data);\n        this.loadingPromises.delete(cacheKey);\n        return data;\n      })\n      .catch(error => {\n        this.loadingPromises.delete(cacheKey);\n        throw error;\n      });\n\n    this.loadingPromises.set(cacheKey, loadingPromise);\n    return loadingPromise;\n  }\n\n  /**\n   * Perform actual data loading\n   */\n  async performLoad(startDate, endDate, filters, loadTasksFn) {\n    if (!loadTasksFn) {\n      throw new Error('loadTasksFn is required');\n    }\n\n    try {\n      // Load tasks in batches if date range is large\n      const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));\n      \n      if (daysDiff > 90) {\n        return this.loadInBatches(startDate, endDate, filters, loadTasksFn);\n      }\n\n      // Direct load for smaller ranges\n      const tasks = await loadTasksFn(startDate, endDate, filters);\n      return this.processLoadedTasks(tasks, startDate, endDate);\n    } catch (error) {\n      console.error('Failed to load calendar data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load data in batches for large date ranges\n   */\n  async loadInBatches(startDate, endDate, filters, loadTasksFn) {\n    const batches = [];\n    let currentStart = new Date(startDate);\n    \n    while (currentStart < endDate) {\n      const batchEnd = new Date(Math.min(\n        currentStart.getTime() + (30 * 24 * 60 * 60 * 1000), // 30 days\n        endDate.getTime()\n      ));\n      \n      batches.push({ start: new Date(currentStart), end: batchEnd });\n      currentStart = new Date(batchEnd.getTime() + 1);\n    }\n\n    // Load batches in parallel with concurrency limit\n    const concurrencyLimit = 3;\n    const results = [];\n    \n    for (let i = 0; i < batches.length; i += concurrencyLimit) {\n      const batchGroup = batches.slice(i, i + concurrencyLimit);\n      const batchPromises = batchGroup.map(batch => \n        loadTasksFn(batch.start, batch.end, filters)\n      );\n      \n      const batchResults = await Promise.all(batchPromises);\n      results.push(...batchResults.flat());\n    }\n\n    return this.processLoadedTasks(results, startDate, endDate);\n  }\n\n  /**\n   * Process and optimize loaded tasks\n   */\n  processLoadedTasks(tasks, startDate, endDate) {\n    // Filter tasks within date range\n    const filteredTasks = tasks.filter(task => {\n      if (!task.due) return false;\n      const taskDate = new Date(task.due);\n      return isWithinInterval(taskDate, { start: startDate, end: endDate });\n    });\n\n    // Sort by due date\n    const sortedTasks = filteredTasks.sort((a, b) => {\n      if (!a.due && !b.due) return 0;\n      if (!a.due) return 1;\n      if (!b.due) return -1;\n      return new Date(a.due) - new Date(b.due);\n    });\n\n    // Create task index for fast lookups\n    const taskIndex = new Map();\n    sortedTasks.forEach(task => {\n      const dateKey = format(new Date(task.due), 'yyyy-MM-dd');\n      if (!taskIndex.has(dateKey)) {\n        taskIndex.set(dateKey, []);\n      }\n      taskIndex.get(dateKey).push(task);\n    });\n\n    return {\n      tasks: sortedTasks,\n      taskIndex,\n      dateRange: { start: startDate, end: endDate },\n      loadedAt: Date.now()\n    };\n  }\n\n  /**\n   * Prefetch data for adjacent periods\n   */\n  prefetchAdjacent(currentDate, view, filters = {}, loadTasksFn) {\n    const prefetchRanges = this.getPrefetchRanges(currentDate, view);\n    \n    prefetchRanges.forEach(range => {\n      const cacheKey = this.getCacheKey(range.start, range.end, filters);\n      \n      // Only prefetch if not already cached or loading\n      if (!this.cache.has(cacheKey) && !this.loadingPromises.has(cacheKey)) {\n        this.prefetchQueue.push({\n          start: range.start,\n          end: range.end,\n          filters,\n          loadTasksFn,\n          priority: 'low'\n        });\n      }\n    });\n  }\n\n  /**\n   * Get prefetch ranges based on current view\n   */\n  getPrefetchRanges(currentDate, view) {\n    const ranges = [];\n    \n    switch (view) {\n      case 'month':\n        // Prefetch previous and next months\n        for (let i = 1; i <= this.options.prefetchDistance; i++) {\n          const prevMonth = subMonths(currentDate, i);\n          const nextMonth = addMonths(currentDate, i);\n          \n          ranges.push({\n            start: startOfWeek(startOfMonth(prevMonth)),\n            end: endOfWeek(endOfMonth(prevMonth))\n          });\n          \n          ranges.push({\n            start: startOfWeek(startOfMonth(nextMonth)),\n            end: endOfWeek(endOfMonth(nextMonth))\n          });\n        }\n        break;\n        \n      case 'week':\n        // Prefetch adjacent weeks\n        for (let i = 1; i <= this.options.prefetchDistance; i++) {\n          const prevWeek = new Date(currentDate.getTime() - (i * 7 * 24 * 60 * 60 * 1000));\n          const nextWeek = new Date(currentDate.getTime() + (i * 7 * 24 * 60 * 60 * 1000));\n          \n          ranges.push({\n            start: startOfWeek(prevWeek),\n            end: endOfWeek(prevWeek)\n          });\n          \n          ranges.push({\n            start: startOfWeek(nextWeek),\n            end: endOfWeek(nextWeek)\n          });\n        }\n        break;\n        \n      case 'day':\n        // Prefetch adjacent days\n        for (let i = 1; i <= 7; i++) {\n          const prevDay = new Date(currentDate.getTime() - (i * 24 * 60 * 60 * 1000));\n          const nextDay = new Date(currentDate.getTime() + (i * 24 * 60 * 60 * 1000));\n          \n          ranges.push({ start: prevDay, end: prevDay });\n          ranges.push({ start: nextDay, end: nextDay });\n        }\n        break;\n    }\n    \n    return ranges;\n  }\n\n  /**\n   * Start background prefetch worker\n   */\n  startPrefetchWorker() {\n    const processPrefetchQueue = async () => {\n      if (this.prefetchQueue.length === 0) {\n        setTimeout(processPrefetchQueue, 1000);\n        return;\n      }\n\n      const item = this.prefetchQueue.shift();\n      \n      try {\n        await this.loadTasks(\n          item.start, \n          item.end, \n          item.filters, \n          { \n            loadTasksFn: item.loadTasksFn,\n            priority: item.priority \n          }\n        );\n      } catch (error) {\n        console.warn('Prefetch failed:', error);\n      }\n\n      // Continue processing with small delay\n      setTimeout(processPrefetchQueue, 100);\n    };\n\n    processPrefetchQueue();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats() {\n    const entries = Array.from(this.cache.values());\n    const now = Date.now();\n    \n    return {\n      size: this.cache.size,\n      maxSize: this.options.maxCacheSize,\n      hitRate: this.calculateHitRate(),\n      averageAge: entries.length > 0 \n        ? entries.reduce((sum, entry) => sum + (now - entry.timestamp), 0) / entries.length\n        : 0,\n      oldestEntry: entries.length > 0 \n        ? Math.min(...entries.map(entry => entry.timestamp))\n        : null,\n      prefetchQueueSize: this.prefetchQueue.length,\n      activeLoads: this.loadingPromises.size\n    };\n  }\n\n  /**\n   * Calculate cache hit rate\n   */\n  calculateHitRate() {\n    // This would need to be tracked over time\n    // For now, return a placeholder\n    return 0;\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache() {\n    this.cache.clear();\n    this.loadingPromises.clear();\n    this.prefetchQueue.length = 0;\n  }\n\n  /**\n   * Invalidate cache entries matching pattern\n   */\n  invalidateCache(pattern) {\n    const keysToDelete = [];\n    \n    for (const key of this.cache.keys()) {\n      if (pattern.test ? pattern.test(key) : key.includes(pattern)) {\n        keysToDelete.push(key);\n      }\n    }\n    \n    keysToDelete.forEach(key => this.cache.delete(key));\n  }\n\n  /**\n   * Preload data for specific date ranges\n   */\n  async preloadRanges(ranges, filters = {}, loadTasksFn) {\n    const promises = ranges.map(range => \n      this.loadTasks(range.start, range.end, filters, { loadTasksFn })\n    );\n    \n    return Promise.all(promises);\n  }\n\n  /**\n   * Get memory usage estimate\n   */\n  getMemoryUsage() {\n    let totalSize = 0;\n    \n    for (const entry of this.cache.values()) {\n      // Rough estimate of object size\n      totalSize += JSON.stringify(entry.data).length * 2; // UTF-16\n    }\n    \n    return {\n      estimatedBytes: totalSize,\n      estimatedMB: totalSize / (1024 * 1024),\n      entries: this.cache.size\n    };\n  }\n}\n\n// Create singleton instance\nconst calendarDataLoader = new CalendarDataLoader();\n\n// Export utilities\nexport const createCalendarDataLoader = (options) => new CalendarDataLoader(options);\nexport const getDefaultDataLoader = () => calendarDataLoader;\nexport default calendarDataLoader;