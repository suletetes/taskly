import React, { memo, useMemo, useCallback, useRef, useEffect } from 'react';\nimport { FixedSizeGrid as Grid, VariableSizeGrid } from 'react-window';\nimport { format, isSameDay, isToday, isWeekend } from 'date-fns';\nimport { useCalendarGridOptimization } from '../../hooks/useCalendarOptimization';\nimport { taskCalendarUtils } from '../../utils/taskCalendarUtils';\nimport CalendarTaskCard from './CalendarTaskCard';\n\n// Memoized date cell component\nconst DateCell = memo(({ \n  date, \n  tasks, \n  isCurrentMonth, \n  isSelected, \n  isToday: isTodayCell,\n  onClick,\n  onTaskClick,\n  style,\n  maxVisibleTasks = 3\n}) => {\n  const cellTasks = useMemo(() => \n    tasks.filter(task => task.due && isSameDay(new Date(task.due), date)),\n    [tasks, date]\n  );\n\n  const visibleTasks = useMemo(() => \n    cellTasks.slice(0, maxVisibleTasks),\n    [cellTasks, maxVisibleTasks]\n  );\n\n  const hiddenTaskCount = cellTasks.length - visibleTasks.length;\n\n  const handleCellClick = useCallback((event) => {\n    if (event.target.closest('.task-card')) return;\n    onClick?.(date, event);\n  }, [date, onClick]);\n\n  return (\n    <div\n      style={style}\n      className={`\n        calendar-date-cell relative border border-secondary-200 dark:border-secondary-700 p-1 cursor-pointer\n        transition-colors duration-150\n        ${isCurrentMonth \n          ? 'bg-white dark:bg-secondary-800' \n          : 'bg-secondary-50 dark:bg-secondary-900 text-secondary-400'\n        }\n        ${isSelected ? 'ring-2 ring-primary-500' : ''}\n        ${isTodayCell ? 'bg-primary-50 dark:bg-primary-900/20' : ''}\n        ${isWeekend(date) ? 'bg-secondary-25 dark:bg-secondary-850' : ''}\n        hover:bg-secondary-100 dark:hover:bg-secondary-700\n      `}\n      onClick={handleCellClick}\n    >\n      {/* Date number */}\n      <div className={`\n        text-sm font-medium mb-1\n        ${isTodayCell ? 'text-primary-600 dark:text-primary-400' : 'text-secondary-900 dark:text-secondary-100'}\n        ${!isCurrentMonth ? 'text-secondary-400' : ''}\n      `}>\n        {format(date, 'd')}\n      </div>\n\n      {/* Tasks */}\n      <div className=\"space-y-0.5 min-h-0 flex-1\">\n        {visibleTasks.map(task => (\n          <CalendarTaskCard\n            key={task._id || task.id}\n            task={task}\n            size=\"xs\"\n            onClick={onTaskClick}\n            showTooltip={false}\n            className=\"task-card\"\n          />\n        ))}\n        \n        {/* Hidden task count */}\n        {hiddenTaskCount > 0 && (\n          <div className=\"text-xs text-secondary-500 dark:text-secondary-400 px-1\">\n            +{hiddenTaskCount} more\n          </div>\n        )}\n      </div>\n    </div>\n  );\n});\n\nDateCell.displayName = 'DateCell';\n\n// Virtualized calendar grid for large date ranges\nconst VirtualizedCalendarGrid = memo(({ \n  dates,\n  tasks,\n  currentMonth,\n  selectedDate,\n  onDateClick,\n  onTaskClick,\n  columnCount = 7,\n  rowHeight = 120,\n  columnWidth = 150\n}) => {\n  const gridRef = useRef();\n  \n  const { taskPositions } = useCalendarGridOptimization({\n    tasks,\n    dateRange: { start: dates[0], end: dates[dates.length - 1] },\n    cellSize: { width: columnWidth, height: rowHeight }\n  });\n\n  const rowCount = Math.ceil(dates.length / columnCount);\n\n  const Cell = useCallback(({ columnIndex, rowIndex, style }) => {\n    const dateIndex = rowIndex * columnCount + columnIndex;\n    const date = dates[dateIndex];\n    \n    if (!date) {\n      return <div style={style} />;\n    }\n\n    return (\n      <DateCell\n        date={date}\n        tasks={tasks}\n        isCurrentMonth={date.getMonth() === currentMonth.getMonth()}\n        isSelected={selectedDate && isSameDay(date, selectedDate)}\n        isToday={isToday(date)}\n        onClick={onDateClick}\n        onTaskClick={onTaskClick}\n        style={style}\n      />\n    );\n  }, [dates, tasks, currentMonth, selectedDate, onDateClick, onTaskClick, columnCount]);\n\n  return (\n    <Grid\n      ref={gridRef}\n      className=\"calendar-grid\"\n      columnCount={columnCount}\n      columnWidth={columnWidth}\n      height={600}\n      rowCount={rowCount}\n      rowHeight={rowHeight}\n      width={columnCount * columnWidth}\n    >\n      {Cell}\n    </Grid>\n  );\n});\n\nVirtualizedCalendarGrid.displayName = 'VirtualizedCalendarGrid';\n\n// Optimized standard calendar grid\nconst OptimizedCalendarGrid = memo(({ \n  dates,\n  tasks,\n  currentMonth,\n  selectedDate,\n  onDateClick,\n  onTaskClick,\n  className = '',\n  useVirtualization = false,\n  cellHeight = 120\n}) => {\n  const gridContainerRef = useRef();\n  \n  // Memoize task grouping by date\n  const tasksByDate = useMemo(() => {\n    const grouped = new Map();\n    \n    tasks.forEach(task => {\n      if (!task.due) return;\n      \n      const dateKey = format(new Date(task.due), 'yyyy-MM-dd');\n      if (!grouped.has(dateKey)) {\n        grouped.set(dateKey, []);\n      }\n      grouped.get(dateKey).push(task);\n    });\n    \n    return grouped;\n  }, [tasks]);\n\n  // Memoize date grid layout\n  const dateGrid = useMemo(() => {\n    const weeks = [];\n    let currentWeek = [];\n    \n    dates.forEach((date, index) => {\n      currentWeek.push(date);\n      \n      if (currentWeek.length === 7 || index === dates.length - 1) {\n        weeks.push([...currentWeek]);\n        currentWeek = [];\n      }\n    });\n    \n    return weeks;\n  }, [dates]);\n\n  // Use virtualization for large grids\n  if (useVirtualization && dates.length > 42) {\n    return (\n      <VirtualizedCalendarGrid\n        dates={dates}\n        tasks={tasks}\n        currentMonth={currentMonth}\n        selectedDate={selectedDate}\n        onDateClick={onDateClick}\n        onTaskClick={onTaskClick}\n      />\n    );\n  }\n\n  return (\n    <div \n      ref={gridContainerRef}\n      className={`optimized-calendar-grid ${className}`}\n    >\n      {/* Week headers */}\n      <div className=\"grid grid-cols-7 gap-0 border-b border-secondary-200 dark:border-secondary-700\">\n        {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day => (\n          <div \n            key={day}\n            className=\"p-2 text-center text-sm font-medium text-secondary-600 dark:text-secondary-400 bg-secondary-50 dark:bg-secondary-900\"\n          >\n            {day}\n          </div>\n        ))}\n      </div>\n\n      {/* Date grid */}\n      <div className=\"grid grid-cols-7 gap-0\">\n        {dates.map(date => {\n          const dateKey = format(date, 'yyyy-MM-dd');\n          const dateTasks = tasksByDate.get(dateKey) || [];\n          \n          return (\n            <DateCell\n              key={dateKey}\n              date={date}\n              tasks={dateTasks}\n              isCurrentMonth={date.getMonth() === currentMonth.getMonth()}\n              isSelected={selectedDate && isSameDay(date, selectedDate)}\n              isToday={isToday(date)}\n              onClick={onDateClick}\n              onTaskClick={onTaskClick}\n              style={{ minHeight: cellHeight }}\n            />\n          );\n        })}\n      </div>\n    </div>\n  );\n});\n\nOptimizedCalendarGrid.displayName = 'OptimizedCalendarGrid';\n\n// Lazy-loaded calendar section for infinite scrolling\nconst LazyCalendarSection = memo(({ \n  monthDate,\n  tasks,\n  onDateClick,\n  onTaskClick,\n  isVisible,\n  onVisibilityChange\n}) => {\n  const sectionRef = useRef();\n  const [isLoaded, setIsLoaded] = useState(false);\n\n  // Intersection observer for lazy loading\n  useEffect(() => {\n    if (!sectionRef.current) return;\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        const visible = entry.isIntersecting;\n        onVisibilityChange?.(monthDate, visible);\n        \n        if (visible && !isLoaded) {\n          setIsLoaded(true);\n        }\n      },\n      { threshold: 0.1 }\n    );\n\n    observer.observe(sectionRef.current);\n\n    return () => observer.disconnect();\n  }, [monthDate, isLoaded, onVisibilityChange]);\n\n  const monthDates = useMemo(() => {\n    return taskCalendarUtils.generateMonthDates(monthDate);\n  }, [monthDate]);\n\n  return (\n    <div ref={sectionRef} className=\"lazy-calendar-section\">\n      <div className=\"sticky top-0 bg-white dark:bg-secondary-900 z-10 p-4 border-b border-secondary-200 dark:border-secondary-700\">\n        <h3 className=\"text-lg font-semibold text-secondary-900 dark:text-secondary-100\">\n          {format(monthDate, 'MMMM yyyy')}\n        </h3>\n      </div>\n      \n      {isLoaded ? (\n        <OptimizedCalendarGrid\n          dates={monthDates}\n          tasks={tasks}\n          currentMonth={monthDate}\n          onDateClick={onDateClick}\n          onTaskClick={onTaskClick}\n        />\n      ) : (\n        <div className=\"h-96 flex items-center justify-center text-secondary-500 dark:text-secondary-400\">\n          <div className=\"animate-pulse\">Loading calendar...</div>\n        </div>\n      )}\n    </div>\n  );\n});\n\nLazyCalendarSection.displayName = 'LazyCalendarSection';\n\n// Performance monitoring wrapper\nconst withPerformanceMonitoring = (Component) => {\n  return memo((props) => {\n    const renderStartTime = useRef();\n    const renderCount = useRef(0);\n\n    useEffect(() => {\n      renderStartTime.current = performance.now();\n      renderCount.current += 1;\n    });\n\n    useEffect(() => {\n      if (renderStartTime.current) {\n        const renderTime = performance.now() - renderStartTime.current;\n        \n        if (renderTime > 16) { // More than one frame at 60fps\n          console.warn(`Slow calendar render: ${renderTime.toFixed(2)}ms (render #${renderCount.current})`);\n        }\n      }\n    });\n\n    return <Component {...props} />;\n  });\n};\n\n// Export optimized components\nexport const MonitoredCalendarGrid = withPerformanceMonitoring(OptimizedCalendarGrid);\nexport { OptimizedCalendarGrid, VirtualizedCalendarGrid, LazyCalendarSection, DateCell };\nexport default OptimizedCalendarGrid;