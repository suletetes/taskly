import React, { useState, useCallback, useEffect } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport {\n  ArrowPathIcon,\n  CalendarIcon,\n  ClockIcon,\n  XMarkIcon,\n  CheckIcon,\n  ExclamationTriangleIcon,\n  InformationCircleIcon,\n  PencilIcon,\n  TrashIcon\n} from '@heroicons/react/24/outline';\nimport { format, addDays, addWeeks, addMonths, addYears, isBefore, isAfter } from 'date-fns';\nimport { useCalendar } from '../../context/CalendarContext';\nimport { taskCalendarUtils } from '../../utils/taskCalendarUtils';\n\nconst RecurringTaskManager = ({\n  task,\n  onUpdate,\n  onDelete,\n  onClose,\n  className = ''\n}) => {\n  const { allTasks, updateTask, removeTask } = useCalendar();\n  \n  const [recurringPattern, setRecurringPattern] = useState({\n    type: 'none', // none, daily, weekly, monthly, yearly, custom\n    interval: 1,\n    daysOfWeek: [], // for weekly: [0,1,2,3,4,5,6] (Sunday = 0)\n    dayOfMonth: null, // for monthly: 1-31\n    monthOfYear: null, // for yearly: 0-11 (January = 0)\n    endType: 'never', // never, after, on\n    endAfter: 10, // number of occurrences\n    endOn: null, // end date\n    exceptions: [] // dates to skip\n  });\n  \n  const [generatedInstances, setGeneratedInstances] = useState([]);\n  const [showPreview, setShowPreview] = useState(false);\n  const [editMode, setEditMode] = useState(false);\n  const [selectedAction, setSelectedAction] = useState('this'); // this, future, all\n\n  // Initialize pattern from task\n  useEffect(() => {\n    if (task?.recurring) {\n      setRecurringPattern(task.recurring);\n      setEditMode(true);\n    }\n  }, [task]);\n\n  // Generate recurring task instances\n  const generateRecurringInstances = useCallback((pattern, startDate, limit = 50) => {\n    if (pattern.type === 'none') return [];\n    \n    const instances = [];\n    let currentDate = new Date(startDate);\n    let count = 0;\n    \n    while (count < limit) {\n      // Check if we've reached the end condition\n      if (pattern.endType === 'after' && count >= pattern.endAfter) break;\n      if (pattern.endType === 'on' && pattern.endOn && isAfter(currentDate, new Date(pattern.endOn))) break;\n      \n      // Check if this date is an exception\n      const isException = pattern.exceptions.some(exception => \n        format(new Date(exception), 'yyyy-MM-dd') === format(currentDate, 'yyyy-MM-dd')\n      );\n      \n      if (!isException) {\n        instances.push({\n          id: `${task._id}-${count}`,\n          date: new Date(currentDate),\n          title: task.title,\n          description: task.description,\n          priority: task.priority,\n          status: count === 0 ? task.status : 'pending', // First instance keeps original status\n          isRecurring: true,\n          recurringId: task._id,\n          instanceNumber: count\n        });\n      }\n      \n      // Calculate next occurrence\n      switch (pattern.type) {\n        case 'daily':\n          currentDate = addDays(currentDate, pattern.interval);\n          break;\n        case 'weekly':\n          if (pattern.daysOfWeek.length > 0) {\n            // Find next day of week\n            let nextDay = new Date(currentDate);\n            let found = false;\n            \n            for (let i = 1; i <= 7; i++) {\n              nextDay = addDays(currentDate, i);\n              if (pattern.daysOfWeek.includes(nextDay.getDay())) {\n                currentDate = nextDay;\n                found = true;\n                break;\n              }\n            }\n            \n            if (!found) {\n              currentDate = addWeeks(currentDate, pattern.interval);\n            }\n          } else {\n            currentDate = addWeeks(currentDate, pattern.interval);\n          }\n          break;\n        case 'monthly':\n          if (pattern.dayOfMonth) {\n            const nextMonth = addMonths(currentDate, pattern.interval);\n            nextMonth.setDate(Math.min(pattern.dayOfMonth, new Date(nextMonth.getFullYear(), nextMonth.getMonth() + 1, 0).getDate()));\n            currentDate = nextMonth;\n          } else {\n            currentDate = addMonths(currentDate, pattern.interval);\n          }\n          break;\n        case 'yearly':\n          currentDate = addYears(currentDate, pattern.interval);\n          break;\n        default:\n          break;\n      }\n      \n      count++;\n    }\n    \n    return instances;\n  }, [task]);\n\n  // Update generated instances when pattern changes\n  useEffect(() => {\n    if (task?.due && recurringPattern.type !== 'none') {\n      const instances = generateRecurringInstances(recurringPattern, task.due);\n      setGeneratedInstances(instances);\n    } else {\n      setGeneratedInstances([]);\n    }\n  }, [recurringPattern, task, generateRecurringInstances]);\n\n  // Handle pattern change\n  const handlePatternChange = useCallback((field, value) => {\n    setRecurringPattern(prev => ({\n      ...prev,\n      [field]: value\n    }));\n  }, []);\n\n  // Handle days of week change for weekly pattern\n  const handleDaysOfWeekChange = useCallback((day, checked) => {\n    setRecurringPattern(prev => ({\n      ...prev,\n      daysOfWeek: checked \n        ? [...prev.daysOfWeek, day].sort()\n        : prev.daysOfWeek.filter(d => d !== day)\n    }));\n  }, []);\n\n  // Handle exception date\n  const handleAddException = useCallback((date) => {\n    setRecurringPattern(prev => ({\n      ...prev,\n      exceptions: [...prev.exceptions, date.toISOString()]\n    }));\n  }, []);\n\n  const handleRemoveException = useCallback((date) => {\n    setRecurringPattern(prev => ({\n      ...prev,\n      exceptions: prev.exceptions.filter(ex => \n        format(new Date(ex), 'yyyy-MM-dd') !== format(new Date(date), 'yyyy-MM-dd')\n      )\n    }));\n  }, []);\n\n  // Save recurring pattern\n  const handleSave = useCallback(async () => {\n    try {\n      const updatedTask = {\n        ...task,\n        recurring: recurringPattern.type !== 'none' ? recurringPattern : null\n      };\n      \n      await onUpdate(updatedTask);\n      \n      // Generate and create recurring instances if needed\n      if (recurringPattern.type !== 'none') {\n        const instances = generateRecurringInstances(recurringPattern, task.due);\n        // Note: In a real implementation, you'd create these instances in the backend\n        console.log('Generated recurring instances:', instances);\n      }\n      \n      onClose();\n    } catch (error) {\n      console.error('Failed to save recurring pattern:', error);\n    }\n  }, [task, recurringPattern, onUpdate, onClose, generateRecurringInstances]);\n\n  // Handle recurring task action (edit this, future, or all)\n  const handleRecurringAction = useCallback(async (action) => {\n    try {\n      switch (action) {\n        case 'this':\n          // Edit only this instance\n          const updatedTask = { ...task, recurring: null };\n          await onUpdate(updatedTask);\n          break;\n        case 'future':\n          // Edit this and future instances\n          // Implementation would depend on backend support\n          break;\n        case 'all':\n          // Edit all instances\n          await onUpdate({ ...task, recurring: recurringPattern });\n          break;\n        default:\n          break;\n      }\n      onClose();\n    } catch (error) {\n      console.error('Failed to update recurring task:', error);\n    }\n  }, [task, recurringPattern, onUpdate, onClose]);\n\n  // Delete recurring task\n  const handleDelete = useCallback(async (action) => {\n    try {\n      switch (action) {\n        case 'this':\n          // Delete only this instance\n          await onDelete(task._id);\n          break;\n        case 'future':\n          // Delete this and future instances\n          // Implementation would depend on backend support\n          break;\n        case 'all':\n          // Delete all instances\n          await onDelete(task._id, { deleteAll: true });\n          break;\n        default:\n          break;\n      }\n      onClose();\n    } catch (error) {\n      console.error('Failed to delete recurring task:', error);\n    }\n  }, [task, onDelete, onClose]);\n\n  // Render pattern configuration\n  const renderPatternConfig = () => {\n    return (\n      <div className=\"space-y-4\">\n        {/* Pattern Type */}\n        <div>\n          <label className=\"block text-sm font-medium text-secondary-700 dark:text-secondary-300 mb-2\">\n            Repeat\n          </label>\n          <select\n            value={recurringPattern.type}\n            onChange={(e) => handlePatternChange('type', e.target.value)}\n            className=\"w-full px-3 py-2 border border-secondary-300 dark:border-secondary-600 rounded-lg bg-white dark:bg-secondary-800 text-secondary-900 dark:text-secondary-100 focus:ring-2 focus:ring-primary-500 focus:border-primary-500\"\n          >\n            <option value=\"none\">Does not repeat</option>\n            <option value=\"daily\">Daily</option>\n            <option value=\"weekly\">Weekly</option>\n            <option value=\"monthly\">Monthly</option>\n            <option value=\"yearly\">Yearly</option>\n          </select>\n        </div>\n\n        {/* Interval */}\n        {recurringPattern.type !== 'none' && (\n          <div>\n            <label className=\"block text-sm font-medium text-secondary-700 dark:text-secondary-300 mb-2\">\n              Every\n            </label>\n            <div className=\"flex items-center space-x-2\">\n              <input\n                type=\"number\"\n                min=\"1\"\n                max=\"365\"\n                value={recurringPattern.interval}\n                onChange={(e) => handlePatternChange('interval', parseInt(e.target.value))}\n                className=\"w-20 px-3 py-2 border border-secondary-300 dark:border-secondary-600 rounded-lg bg-white dark:bg-secondary-800 text-secondary-900 dark:text-secondary-100 focus:ring-2 focus:ring-primary-500 focus:border-primary-500\"\n              />\n              <span className=\"text-sm text-secondary-600 dark:text-secondary-400\">\n                {recurringPattern.type === 'daily' && (recurringPattern.interval === 1 ? 'day' : 'days')}\n                {recurringPattern.type === 'weekly' && (recurringPattern.interval === 1 ? 'week' : 'weeks')}\n                {recurringPattern.type === 'monthly' && (recurringPattern.interval === 1 ? 'month' : 'months')}\n                {recurringPattern.type === 'yearly' && (recurringPattern.interval === 1 ? 'year' : 'years')}\n              </span>\n            </div>\n          </div>\n        )}\n\n        {/* Days of Week (for weekly) */}\n        {recurringPattern.type === 'weekly' && (\n          <div>\n            <label className=\"block text-sm font-medium text-secondary-700 dark:text-secondary-300 mb-2\">\n              Repeat on\n            </label>\n            <div className=\"flex flex-wrap gap-2\">\n              {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day, index) => (\n                <label key={day} className=\"flex items-center space-x-2 cursor-pointer\">\n                  <input\n                    type=\"checkbox\"\n                    checked={recurringPattern.daysOfWeek.includes(index)}\n                    onChange={(e) => handleDaysOfWeekChange(index, e.target.checked)}\n                    className=\"rounded border-secondary-300 dark:border-secondary-600 text-primary-600 focus:ring-primary-500\"\n                  />\n                  <span className=\"text-sm text-secondary-700 dark:text-secondary-300\">{day}</span>\n                </label>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {/* End Condition */}\n        {recurringPattern.type !== 'none' && (\n          <div>\n            <label className=\"block text-sm font-medium text-secondary-700 dark:text-secondary-300 mb-2\">\n              Ends\n            </label>\n            <div className=\"space-y-2\">\n              <label className=\"flex items-center space-x-2 cursor-pointer\">\n                <input\n                  type=\"radio\"\n                  name=\"endType\"\n                  value=\"never\"\n                  checked={recurringPattern.endType === 'never'}\n                  onChange={(e) => handlePatternChange('endType', e.target.value)}\n                  className=\"text-primary-600 focus:ring-primary-500\"\n                />\n                <span className=\"text-sm text-secondary-700 dark:text-secondary-300\">Never</span>\n              </label>\n              \n              <label className=\"flex items-center space-x-2 cursor-pointer\">\n                <input\n                  type=\"radio\"\n                  name=\"endType\"\n                  value=\"after\"\n                  checked={recurringPattern.endType === 'after'}\n                  onChange={(e) => handlePatternChange('endType', e.target.value)}\n                  className=\"text-primary-600 focus:ring-primary-500\"\n                />\n                <span className=\"text-sm text-secondary-700 dark:text-secondary-300\">After</span>\n                <input\n                  type=\"number\"\n                  min=\"1\"\n                  max=\"999\"\n                  value={recurringPattern.endAfter}\n                  onChange={(e) => handlePatternChange('endAfter', parseInt(e.target.value))}\n                  disabled={recurringPattern.endType !== 'after'}\n                  className=\"w-16 px-2 py-1 text-sm border border-secondary-300 dark:border-secondary-600 rounded bg-white dark:bg-secondary-800 text-secondary-900 dark:text-secondary-100 disabled:opacity-50\"\n                />\n                <span className=\"text-sm text-secondary-700 dark:text-secondary-300\">occurrences</span>\n              </label>\n              \n              <label className=\"flex items-center space-x-2 cursor-pointer\">\n                <input\n                  type=\"radio\"\n                  name=\"endType\"\n                  value=\"on\"\n                  checked={recurringPattern.endType === 'on'}\n                  onChange={(e) => handlePatternChange('endType', e.target.value)}\n                  className=\"text-primary-600 focus:ring-primary-500\"\n                />\n                <span className=\"text-sm text-secondary-700 dark:text-secondary-300\">On</span>\n                <input\n                  type=\"date\"\n                  value={recurringPattern.endOn ? format(new Date(recurringPattern.endOn), 'yyyy-MM-dd') : ''}\n                  onChange={(e) => handlePatternChange('endOn', e.target.value ? new Date(e.target.value).toISOString() : null)}\n                  disabled={recurringPattern.endType !== 'on'}\n                  className=\"px-2 py-1 text-sm border border-secondary-300 dark:border-secondary-600 rounded bg-white dark:bg-secondary-800 text-secondary-900 dark:text-secondary-100 disabled:opacity-50\"\n                />\n              </label>\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Render preview of generated instances\n  const renderPreview = () => {\n    if (generatedInstances.length === 0) return null;\n\n    return (\n      <div className=\"mt-6\">\n        <div className=\"flex items-center justify-between mb-3\">\n          <h4 className=\"text-sm font-medium text-secondary-700 dark:text-secondary-300\">\n            Preview ({generatedInstances.length} occurrences)\n          </h4>\n          <button\n            onClick={() => setShowPreview(!showPreview)}\n            className=\"text-sm text-primary-600 dark:text-primary-400 hover:underline\"\n          >\n            {showPreview ? 'Hide' : 'Show'} Preview\n          </button>\n        </div>\n        \n        <AnimatePresence>\n          {showPreview && (\n            <motion.div\n              initial={{ height: 0, opacity: 0 }}\n              animate={{ height: 'auto', opacity: 1 }}\n              exit={{ height: 0, opacity: 0 }}\n              className=\"overflow-hidden\"\n            >\n              <div className=\"max-h-48 overflow-y-auto border border-secondary-200 dark:border-secondary-700 rounded-lg\">\n                {generatedInstances.slice(0, 10).map((instance, index) => (\n                  <div\n                    key={instance.id}\n                    className=\"flex items-center justify-between p-3 border-b border-secondary-200 dark:border-secondary-700 last:border-b-0\"\n                  >\n                    <div className=\"flex items-center space-x-3\">\n                      <CalendarIcon className=\"w-4 h-4 text-secondary-400\" />\n                      <div>\n                        <p className=\"text-sm font-medium text-secondary-900 dark:text-secondary-100\">\n                          {format(instance.date, 'EEEE, MMMM d, yyyy')}\n                        </p>\n                        <p className=\"text-xs text-secondary-500 dark:text-secondary-400\">\n                          {instance.title}\n                        </p>\n                      </div>\n                    </div>\n                    <span className={`px-2 py-1 text-xs rounded-full ${\n                      instance.priority === 'high' ? 'bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400' :\n                      instance.priority === 'medium' ? 'bg-yellow-100 text-yellow-700 dark:bg-yellow-900/30 dark:text-yellow-400' :\n                      'bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-400'\n                    }`}>\n                      {instance.priority}\n                    </span>\n                  </div>\n                ))}\n                {generatedInstances.length > 10 && (\n                  <div className=\"p-3 text-center text-sm text-secondary-500 dark:text-secondary-400\">\n                    ... and {generatedInstances.length - 10} more\n                  </div>\n                )}\n              </div>\n            </motion.div>\n          )}\n        </AnimatePresence>\n      </div>\n    );\n  };\n\n  // Render recurring task action selector\n  const renderActionSelector = () => {\n    if (!task?.recurring) return null;\n\n    return (\n      <div className=\"mb-6 p-4 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg\">\n        <div className=\"flex items-start space-x-3\">\n          <InformationCircleIcon className=\"w-5 h-5 text-blue-600 dark:text-blue-400 mt-0.5\" />\n          <div className=\"flex-1\">\n            <h4 className=\"text-sm font-medium text-blue-900 dark:text-blue-100 mb-2\">\n              This is a recurring task\n            </h4>\n            <p className=\"text-sm text-blue-700 dark:text-blue-300 mb-3\">\n              What would you like to edit?\n            </p>\n            <div className=\"space-y-2\">\n              <label className=\"flex items-center space-x-2 cursor-pointer\">\n                <input\n                  type=\"radio\"\n                  name=\"action\"\n                  value=\"this\"\n                  checked={selectedAction === 'this'}\n                  onChange={(e) => setSelectedAction(e.target.value)}\n                  className=\"text-blue-600 focus:ring-blue-500\"\n                />\n                <span className=\"text-sm text-blue-700 dark:text-blue-300\">Only this occurrence</span>\n              </label>\n              <label className=\"flex items-center space-x-2 cursor-pointer\">\n                <input\n                  type=\"radio\"\n                  name=\"action\"\n                  value=\"future\"\n                  checked={selectedAction === 'future'}\n                  onChange={(e) => setSelectedAction(e.target.value)}\n                  className=\"text-blue-600 focus:ring-blue-500\"\n                />\n                <span className=\"text-sm text-blue-700 dark:text-blue-300\">This and future occurrences</span>\n              </label>\n              <label className=\"flex items-center space-x-2 cursor-pointer\">\n                <input\n                  type=\"radio\"\n                  name=\"action\"\n                  value=\"all\"\n                  checked={selectedAction === 'all'}\n                  onChange={(e) => setSelectedAction(e.target.value)}\n                  className=\"text-blue-600 focus:ring-blue-500\"\n                />\n                <span className=\"text-sm text-blue-700 dark:text-blue-300\">All occurrences</span>\n              </label>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div className={`recurring-task-manager ${className}`}>\n      <div className=\"flex items-center justify-between mb-6\">\n        <div className=\"flex items-center space-x-2\">\n          <ArrowPathIcon className=\"w-5 h-5 text-primary-600 dark:text-primary-400\" />\n          <h3 className=\"text-lg font-semibold text-secondary-900 dark:text-secondary-100\">\n            {editMode ? 'Edit Recurring Task' : 'Make Task Recurring'}\n          </h3>\n        </div>\n        <button\n          onClick={onClose}\n          className=\"p-2 text-secondary-400 hover:text-secondary-600 dark:hover:text-secondary-300 rounded-lg hover:bg-secondary-100 dark:hover:bg-secondary-700 transition-colors\"\n        >\n          <XMarkIcon className=\"w-5 h-5\" />\n        </button>\n      </div>\n\n      {renderActionSelector()}\n      {renderPatternConfig()}\n      {renderPreview()}\n\n      {/* Actions */}\n      <div className=\"flex items-center justify-between mt-8 pt-6 border-t border-secondary-200 dark:border-secondary-700\">\n        <div className=\"flex items-center space-x-3\">\n          {task?.recurring && (\n            <button\n              onClick={() => handleDelete(selectedAction)}\n              className=\"flex items-center space-x-2 px-4 py-2 text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition-colors\"\n            >\n              <TrashIcon className=\"w-4 h-4\" />\n              <span>Delete</span>\n            </button>\n          )}\n        </div>\n        \n        <div className=\"flex items-center space-x-3\">\n          <button\n            onClick={onClose}\n            className=\"px-4 py-2 text-secondary-600 dark:text-secondary-400 hover:text-secondary-800 dark:hover:text-secondary-200 rounded-lg hover:bg-secondary-100 dark:hover:bg-secondary-700 transition-colors\"\n          >\n            Cancel\n          </button>\n          <button\n            onClick={task?.recurring ? () => handleRecurringAction(selectedAction) : handleSave}\n            className=\"flex items-center space-x-2 px-4 py-2 bg-primary-600 text-white rounded-lg hover:bg-primary-700 transition-colors\"\n          >\n            <CheckIcon className=\"w-4 h-4\" />\n            <span>Save</span>\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default RecurringTaskManager;