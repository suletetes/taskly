import React from 'react';
import { render, screen, fireEvent, waitFor, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { BrowserRouter } from 'react-router-dom';
import { format, addDays, startOfWeek, endOfWeek } from 'date-fns';

// Test utilities
import { createMockTask, createMockUser } from '../utils/testUtils';
import { CalendarProvider } from '../../context/CalendarContext';
import { AuthProvider } from '../../context/AuthContext';

// Components
import Calendar from '../../pages/Calendar';
import { CALENDAR_VIEWS } from '../../utils/calendarRouting';

// Mock hooks
jest.mock('../../hooks/useTasks', () => ({
  useTasks: () => ({
    tasks: mockTasks,
    fetchTasks: jest.fn(),
    refreshTasks: jest.fn(),
    loading: false,
    error: null
  }),
  useTaskOperations: () => ({
    createTask: jest.fn().mockResolvedValue(createMockTask()),
    updateTaskStatus: jest.fn().mockResolvedValue(createMockTask()),
    deleteTask: jest.fn().mockResolvedValue(true),
    loading: false
  })
}));\n\n// Mock data\nconst mockUser = createMockUser();\nconst mockTasks = [\n  createMockTask({\n    _id: '1',\n    title: 'Task 1',\n    due: new Date().toISOString(),\n    priority: 'high',\n    status: 'pending'\n  }),\n  createMockTask({\n    _id: '2',\n    title: 'Task 2',\n    due: addDays(new Date(), 1).toISOString(),\n    priority: 'medium',\n    status: 'in-progress'\n  }),\n  createMockTask({\n    _id: '3',\n    title: 'Task 3',\n    due: addDays(new Date(), 7).toISOString(),\n    priority: 'low',\n    status: 'completed'\n  })\n];\n\n// Test wrapper component\nconst TestWrapper = ({ children, initialRoute = '/calendar' }) => {\n  return (\n    <BrowserRouter>\n      <AuthProvider value={{ user: mockUser, loading: false }}>\n        <CalendarProvider>\n          {children}\n        </CalendarProvider>\n      </AuthProvider>\n    </BrowserRouter>\n  );\n};\n\n// Helper functions\nconst renderCalendar = (props = {}) => {\n  return render(\n    <TestWrapper>\n      <Calendar {...props} />\n    </TestWrapper>\n  );\n};\n\ndescribe('Calendar Integration Tests', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    // Mock window.innerWidth for mobile detection\n    Object.defineProperty(window, 'innerWidth', {\n      writable: true,\n      configurable: true,\n      value: 1024\n    });\n  });\n\n  describe('Calendar Rendering', () => {\n    test('renders calendar with default month view', async () => {\n      renderCalendar();\n      \n      await waitFor(() => {\n        expect(screen.getByText('Calendar')).toBeInTheDocument();\n        expect(screen.getByText('Month')).toBeInTheDocument();\n      });\n    });\n\n    test('renders all view options', async () => {\n      renderCalendar();\n      \n      await waitFor(() => {\n        expect(screen.getByText('Month')).toBeInTheDocument();\n        expect(screen.getByText('Week')).toBeInTheDocument();\n        expect(screen.getByText('Day')).toBeInTheDocument();\n        expect(screen.getByText('Agenda')).toBeInTheDocument();\n      });\n    });\n\n    test('displays tasks in calendar', async () => {\n      renderCalendar();\n      \n      await waitFor(() => {\n        expect(screen.getByText('Task 1')).toBeInTheDocument();\n        expect(screen.getByText('Task 2')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('View Switching', () => {\n    test('switches between calendar views', async () => {\n      const user = userEvent.setup();\n      renderCalendar();\n      \n      // Switch to week view\n      await user.click(screen.getByText('Week'));\n      await waitFor(() => {\n        expect(screen.getByText('Week')).toHaveClass('bg-white');\n      });\n      \n      // Switch to day view\n      await user.click(screen.getByText('Day'));\n      await waitFor(() => {\n        expect(screen.getByText('Day')).toHaveClass('bg-white');\n      });\n      \n      // Switch to agenda view\n      await user.click(screen.getByText('Agenda'));\n      await waitFor(() => {\n        expect(screen.getByText('Agenda')).toHaveClass('bg-white');\n      });\n    });\n\n    test('maintains tasks visibility across views', async () => {\n      const user = userEvent.setup();\n      renderCalendar();\n      \n      // Verify task is visible in month view\n      await waitFor(() => {\n        expect(screen.getByText('Task 1')).toBeInTheDocument();\n      });\n      \n      // Switch to week view\n      await user.click(screen.getByText('Week'));\n      await waitFor(() => {\n        expect(screen.getByText('Task 1')).toBeInTheDocument();\n      });\n      \n      // Switch to day view\n      await user.click(screen.getByText('Day'));\n      await waitFor(() => {\n        expect(screen.getByText('Task 1')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Date Navigation', () => {\n    test('navigates to previous and next periods', async () => {\n      const user = userEvent.setup();\n      renderCalendar();\n      \n      const prevButton = screen.getByLabelText(/previous/i) || screen.getByRole('button', { name: /previous/i });\n      const nextButton = screen.getByLabelText(/next/i) || screen.getByRole('button', { name: /next/i });\n      \n      // Navigate to previous month\n      await user.click(prevButton);\n      await waitFor(() => {\n        // Should show previous month\n        expect(screen.getByText(/\\w+ \\d{4}/)).toBeInTheDocument();\n      });\n      \n      // Navigate to next month (back to current)\n      await user.click(nextButton);\n      await waitFor(() => {\n        expect(screen.getByText(/\\w+ \\d{4}/)).toBeInTheDocument();\n      });\n    });\n\n    test('goes to today when today button is clicked', async () => {\n      const user = userEvent.setup();\n      renderCalendar();\n      \n      const todayButton = screen.getByText('Today');\n      await user.click(todayButton);\n      \n      await waitFor(() => {\n        const currentMonth = format(new Date(), 'MMMM yyyy');\n        expect(screen.getByText(currentMonth)).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Task Interactions', () => {\n    test('opens task details when task is clicked', async () => {\n      const user = userEvent.setup();\n      renderCalendar();\n      \n      await waitFor(() => {\n        expect(screen.getByText('Task 1')).toBeInTheDocument();\n      });\n      \n      await user.click(screen.getByText('Task 1'));\n      \n      await waitFor(() => {\n        // Should open task form/modal\n        expect(screen.getByDisplayValue('Task 1')).toBeInTheDocument();\n      });\n    });\n\n    test('creates new task when date is clicked', async () => {\n      const user = userEvent.setup();\n      renderCalendar();\n      \n      // Click on a date cell (assuming it has a data-testid)\n      const dateCell = screen.getAllByRole('button')[0]; // First clickable date\n      await user.click(dateCell);\n      \n      await waitFor(() => {\n        // Should open quick create modal\n        expect(screen.getByText(/create task/i)).toBeInTheDocument();\n      });\n    });\n\n    test('shows floating action button for task creation', async () => {\n      renderCalendar();\n      \n      await waitFor(() => {\n        const fab = screen.getByRole('button', { name: /add task/i });\n        expect(fab).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Filtering and Search', () => {\n    test('opens and closes filter panel', async () => {\n      const user = userEvent.setup();\n      renderCalendar();\n      \n      const filterButton = screen.getByRole('button', { name: /filter/i });\n      await user.click(filterButton);\n      \n      await waitFor(() => {\n        expect(screen.getByText(/priority/i)).toBeInTheDocument();\n      });\n      \n      // Close filters\n      await user.click(filterButton);\n      \n      await waitFor(() => {\n        expect(screen.queryByText(/priority/i)).not.toBeInTheDocument();\n      });\n    });\n\n    test('searches for tasks', async () => {\n      const user = userEvent.setup();\n      renderCalendar();\n      \n      const searchInput = screen.getByPlaceholderText(/search/i);\n      await user.type(searchInput, 'Task 1');\n      \n      await waitFor(() => {\n        // Should show search results\n        expect(screen.getByText('Task 1')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Responsive Behavior', () => {\n    test('switches to mobile view on small screens', async () => {\n      // Mock mobile screen size\n      Object.defineProperty(window, 'innerWidth', {\n        writable: true,\n        configurable: true,\n        value: 600\n      });\n      \n      // Trigger resize event\n      fireEvent(window, new Event('resize'));\n      \n      renderCalendar();\n      \n      await waitFor(() => {\n        // Should render mobile calendar\n        expect(screen.getByText('Day')).toBeInTheDocument();\n        expect(screen.getByText('Week')).toBeInTheDocument();\n        expect(screen.getByText('List')).toBeInTheDocument();\n      });\n    });\n\n    test('handles touch interactions on mobile', async () => {\n      // Mock mobile screen size\n      Object.defineProperty(window, 'innerWidth', {\n        writable: true,\n        configurable: true,\n        value: 600\n      });\n      \n      fireEvent(window, new Event('resize'));\n      renderCalendar();\n      \n      // Simulate touch events\n      const calendarContainer = screen.getByRole('main');\n      \n      fireEvent.touchStart(calendarContainer, {\n        touches: [{ clientX: 100, clientY: 100 }]\n      });\n      \n      fireEvent.touchMove(calendarContainer, {\n        touches: [{ clientX: 200, clientY: 100 }]\n      });\n      \n      fireEvent.touchEnd(calendarContainer, {\n        changedTouches: [{ clientX: 200, clientY: 100 }]\n      });\n      \n      // Should handle swipe navigation\n      await waitFor(() => {\n        expect(calendarContainer).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Notifications', () => {\n    test('displays notification bell', async () => {\n      renderCalendar();\n      \n      await waitFor(() => {\n        const notificationBell = screen.getByRole('button', { name: /notifications/i });\n        expect(notificationBell).toBeInTheDocument();\n      });\n    });\n\n    test('shows notification panel when bell is clicked', async () => {\n      const user = userEvent.setup();\n      renderCalendar();\n      \n      const notificationBell = screen.getByRole('button', { name: /notifications/i });\n      await user.click(notificationBell);\n      \n      await waitFor(() => {\n        expect(screen.getByText(/notifications/i)).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Error Handling', () => {\n    test('displays error message when tasks fail to load', async () => {\n      // Mock error state\n      jest.doMock('../../hooks/useTasks', () => ({\n        useTasks: () => ({\n          tasks: [],\n          fetchTasks: jest.fn(),\n          refreshTasks: jest.fn(),\n          loading: false,\n          error: 'Failed to load tasks'\n        }),\n        useTaskOperations: () => ({\n          createTask: jest.fn(),\n          updateTaskStatus: jest.fn(),\n          deleteTask: jest.fn(),\n          loading: false\n        })\n      }));\n      \n      renderCalendar();\n      \n      await waitFor(() => {\n        expect(screen.getByText(/failed to load/i)).toBeInTheDocument();\n        expect(screen.getByText(/retry/i)).toBeInTheDocument();\n      });\n    });\n\n    test('shows loading state while tasks are loading', async () => {\n      // Mock loading state\n      jest.doMock('../../hooks/useTasks', () => ({\n        useTasks: () => ({\n          tasks: [],\n          fetchTasks: jest.fn(),\n          refreshTasks: jest.fn(),\n          loading: true,\n          error: null\n        }),\n        useTaskOperations: () => ({\n          createTask: jest.fn(),\n          updateTaskStatus: jest.fn(),\n          deleteTask: jest.fn(),\n          loading: false\n        })\n      }));\n      \n      renderCalendar();\n      \n      await waitFor(() => {\n        expect(screen.getByText(/loading calendar/i)).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Accessibility', () => {\n    test('has proper ARIA labels', async () => {\n      renderCalendar();\n      \n      await waitFor(() => {\n        expect(screen.getByRole('main')).toBeInTheDocument();\n        expect(screen.getByRole('navigation')).toBeInTheDocument();\n      });\n    });\n\n    test('supports keyboard navigation', async () => {\n      const user = userEvent.setup();\n      renderCalendar();\n      \n      // Test tab navigation\n      await user.tab();\n      expect(document.activeElement).toBeInTheDocument();\n      \n      // Test keyboard shortcuts\n      await user.keyboard('{m}');\n      await waitFor(() => {\n        expect(screen.getByText('Month')).toHaveClass('bg-white');\n      });\n      \n      await user.keyboard('{w}');\n      await waitFor(() => {\n        expect(screen.getByText('Week')).toHaveClass('bg-white');\n      });\n    });\n\n    test('has proper focus management', async () => {\n      const user = userEvent.setup();\n      renderCalendar();\n      \n      // Focus should be manageable\n      const firstFocusable = screen.getAllByRole('button')[0];\n      firstFocusable.focus();\n      \n      expect(document.activeElement).toBe(firstFocusable);\n    });\n  });\n\n  describe('Performance', () => {\n    test('renders within acceptable time', async () => {\n      const startTime = performance.now();\n      renderCalendar();\n      \n      await waitFor(() => {\n        expect(screen.getByText('Calendar')).toBeInTheDocument();\n      });\n      \n      const endTime = performance.now();\n      const renderTime = endTime - startTime;\n      \n      // Should render within 1 second\n      expect(renderTime).toBeLessThan(1000);\n    });\n\n    test('handles large number of tasks efficiently', async () => {\n      // Create many mock tasks\n      const manyTasks = Array.from({ length: 100 }, (_, i) => \n        createMockTask({\n          _id: `task-${i}`,\n          title: `Task ${i}`,\n          due: addDays(new Date(), i % 30).toISOString()\n        })\n      );\n      \n      // Mock the hook to return many tasks\n      jest.doMock('../../hooks/useTasks', () => ({\n        useTasks: () => ({\n          tasks: manyTasks,\n          fetchTasks: jest.fn(),\n          refreshTasks: jest.fn(),\n          loading: false,\n          error: null\n        }),\n        useTaskOperations: () => ({\n          createTask: jest.fn(),\n          updateTaskStatus: jest.fn(),\n          deleteTask: jest.fn(),\n          loading: false\n        })\n      }));\n      \n      const startTime = performance.now();\n      renderCalendar();\n      \n      await waitFor(() => {\n        expect(screen.getByText('Calendar')).toBeInTheDocument();\n      });\n      \n      const endTime = performance.now();\n      const renderTime = endTime - startTime;\n      \n      // Should still render efficiently with many tasks\n      expect(renderTime).toBeLessThan(2000);\n    });\n  });\n});