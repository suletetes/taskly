import React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { DndProvider } from 'react-dnd';\nimport { HTML5Backend } from 'react-dnd-html5-backend';\n\n// Import components to test\nimport CalendarTaskCard from '../../components/calendar/CalendarTaskCard';\nimport TaskQuickCreate from '../../components/calendar/TaskQuickCreate';\nimport TaskDragPreview, { useDragAndDrop } from '../../components/calendar/TaskDragPreview';\n\n// Mock data\nconst mockTask = {\n  _id: 'task-1',\n  title: 'Test Task',\n  description: 'Test Description',\n  due: new Date('2024-01-15T10:30:00Z').toISOString(),\n  priority: 'high',\n  status: 'pending',\n  tags: ['work', 'urgent'],\n  project: {\n    _id: 'project-1',\n    name: 'Test Project'\n  },\n  assignee: {\n    _id: 'user-1',\n    name: 'John Doe'\n  }\n};\n\nconst mockRecurringTask = {\n  ...mockTask,\n  _id: 'recurring-task-1',\n  title: 'Recurring Task',\n  recurring: {\n    type: 'daily',\n    interval: 1,\n    endType: 'never'\n  },\n  isRecurring: true\n};\n\n// Test wrapper with DnD provider\nconst DndTestWrapper = ({ children }) => (\n  <DndProvider backend={HTML5Backend}>\n    {children}\n  </DndProvider>\n);\n\ndescribe('Task Integration Components', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('CalendarTaskCard', () => {\n    const defaultProps = {\n      task: mockTask,\n      onClick: jest.fn(),\n      onEdit: jest.fn(),\n      onDelete: jest.fn(),\n      onStatusChange: jest.fn()\n    };\n\n    test('renders task card with basic information', () => {\n      render(<CalendarTaskCard {...defaultProps} />);\n      \n      expect(screen.getByText('Test Task')).toBeInTheDocument();\n      expect(screen.getByText('10:30 AM')).toBeInTheDocument();\n    });\n\n    test('displays priority indicator', () => {\n      render(<CalendarTaskCard {...defaultProps} />);\n      \n      const card = screen.getByText('Test Task').closest('.calendar-task-card');\n      expect(card).toHaveClass('bg-red-500'); // High priority color\n    });\n\n    test('shows recurring task indicator', () => {\n      render(\n        <CalendarTaskCard \n          {...defaultProps} \n          task={mockRecurringTask}\n        />\n      );\n      \n      const recurringIndicator = document.querySelector('.recurring-task-indicator');\n      expect(recurringIndicator).toBeInTheDocument();\n    });\n\n    test('handles click events', async () => {\n      const user = userEvent.setup();\n      render(<CalendarTaskCard {...defaultProps} />);\n      \n      await user.click(screen.getByText('Test Task'));\n      \n      expect(defaultProps.onClick).toHaveBeenCalledWith(\n        mockTask,\n        expect.any(Object)\n      );\n    });\n\n    test('shows actions on hover', async () => {\n      const user = userEvent.setup();\n      render(<CalendarTaskCard {...defaultProps} />);\n      \n      const card = screen.getByText('Test Task').closest('.calendar-task-card');\n      await user.hover(card);\n      \n      // Should show action buttons\n      await waitFor(() => {\n        expect(screen.getByRole('button', { name: /more actions/i })).toBeInTheDocument();\n      });\n    });\n\n    test('handles status change', async () => {\n      const user = userEvent.setup();\n      render(<CalendarTaskCard {...defaultProps} />);\n      \n      const card = screen.getByText('Test Task').closest('.calendar-task-card');\n      await user.hover(card);\n      \n      await waitFor(() => {\n        const completeButton = screen.getByRole('button', { name: /mark as completed/i });\n        return user.click(completeButton);\n      });\n      \n      expect(defaultProps.onStatusChange).toHaveBeenCalledWith(\n        mockTask,\n        'completed'\n      );\n    });\n\n    test('supports different sizes', () => {\n      const { rerender } = render(\n        <CalendarTaskCard {...defaultProps} size=\"xs\" />\n      );\n      \n      let card = screen.getByText('Test Task').closest('.calendar-task-card');\n      expect(card).toHaveClass('text-xs');\n      \n      rerender(\n        <CalendarTaskCard {...defaultProps} size=\"lg\" />\n      );\n      \n      card = screen.getByText('Test Task').closest('.calendar-task-card');\n      expect(card).toHaveClass('text-sm');\n    });\n\n    test('handles completed task styling', () => {\n      const completedTask = { ...mockTask, status: 'completed' };\n      render(\n        <CalendarTaskCard {...defaultProps} task={completedTask} />\n      );\n      \n      const title = screen.getByText('Test Task');\n      expect(title).toHaveClass('line-through', 'opacity-75');\n    });\n\n    test('supports drag and drop', () => {\n      render(\n        <DndTestWrapper>\n          <CalendarTaskCard {...defaultProps} isDraggable={true} />\n        </DndTestWrapper>\n      );\n      \n      const card = screen.getByText('Test Task').closest('.calendar-task-card');\n      expect(card).toHaveAttribute('draggable', 'true');\n    });\n\n    test('shows tooltip with task details', async () => {\n      const user = userEvent.setup();\n      render(<CalendarTaskCard {...defaultProps} showTooltip={true} />);\n      \n      const card = screen.getByText('Test Task').closest('.calendar-task-card');\n      \n      await user.hover(card);\n      \n      // Should show tooltip with task details\n      await waitFor(() => {\n        expect(card).toHaveAttribute('title');\n      });\n    });\n\n    test('handles overdue tasks', () => {\n      const overdueTask = {\n        ...mockTask,\n        due: new Date('2020-01-01T10:00:00Z').toISOString(),\n        status: 'pending'\n      };\n      \n      render(\n        <CalendarTaskCard {...defaultProps} task={overdueTask} />\n      );\n      \n      const statusIcon = document.querySelector('.text-red-500');\n      expect(statusIcon).toBeInTheDocument();\n    });\n  });\n\n  describe('TaskQuickCreate', () => {\n    const defaultProps = {\n      isOpen: true,\n      onClose: jest.fn(),\n      onSubmit: jest.fn(),\n      selectedDate: new Date('2024-01-15'),\n      selectedTime: { hour: 10, minutes: 30 },\n      isLoading: false\n    };\n\n    test('renders quick create modal', () => {\n      render(<TaskQuickCreate {...defaultProps} />);\n      \n      expect(screen.getByText(/create task/i)).toBeInTheDocument();\n      expect(screen.getByLabelText(/title/i)).toBeInTheDocument();\n      expect(screen.getByLabelText(/description/i)).toBeInTheDocument();\n    });\n\n    test('pre-fills date and time', () => {\n      render(<TaskQuickCreate {...defaultProps} />);\n      \n      const dateInput = screen.getByDisplayValue('2024-01-15');\n      const timeInput = screen.getByDisplayValue('10:30');\n      \n      expect(dateInput).toBeInTheDocument();\n      expect(timeInput).toBeInTheDocument();\n    });\n\n    test('handles form submission', async () => {\n      const user = userEvent.setup();\n      render(<TaskQuickCreate {...defaultProps} />);\n      \n      // Fill in the form\n      await user.type(screen.getByLabelText(/title/i), 'New Task');\n      await user.type(screen.getByLabelText(/description/i), 'Task description');\n      \n      // Submit the form\n      await user.click(screen.getByRole('button', { name: /create/i }));\n      \n      expect(defaultProps.onSubmit).toHaveBeenCalledWith(\n        expect.objectContaining({\n          title: 'New Task',\n          description: 'Task description'\n        })\n      );\n    });\n\n    test('handles form cancellation', async () => {\n      const user = userEvent.setup();\n      render(<TaskQuickCreate {...defaultProps} />);\n      \n      await user.click(screen.getByRole('button', { name: /cancel/i }));\n      \n      expect(defaultProps.onClose).toHaveBeenCalled();\n    });\n\n    test('validates required fields', async () => {\n      const user = userEvent.setup();\n      render(<TaskQuickCreate {...defaultProps} />);\n      \n      // Try to submit without title\n      await user.click(screen.getByRole('button', { name: /create/i }));\n      \n      expect(screen.getByText(/title is required/i)).toBeInTheDocument();\n      expect(defaultProps.onSubmit).not.toHaveBeenCalled();\n    });\n\n    test('shows loading state', () => {\n      render(<TaskQuickCreate {...defaultProps} isLoading={true} />);\n      \n      const submitButton = screen.getByRole('button', { name: /creating/i });\n      expect(submitButton).toBeDisabled();\n    });\n\n    test('handles priority selection', async () => {\n      const user = userEvent.setup();\n      render(<TaskQuickCreate {...defaultProps} />);\n      \n      const prioritySelect = screen.getByLabelText(/priority/i);\n      await user.selectOptions(prioritySelect, 'high');\n      \n      expect(prioritySelect.value).toBe('high');\n    });\n\n    test('supports keyboard shortcuts', async () => {\n      const user = userEvent.setup();\n      render(<TaskQuickCreate {...defaultProps} />);\n      \n      // Escape to close\n      await user.keyboard('{Escape}');\n      expect(defaultProps.onClose).toHaveBeenCalled();\n    });\n\n    test('does not render when closed', () => {\n      render(<TaskQuickCreate {...defaultProps} isOpen={false} />);\n      \n      expect(screen.queryByText(/create task/i)).not.toBeInTheDocument();\n    });\n  });\n\n  describe('TaskDragPreview', () => {\n    const defaultProps = {\n      draggedTask: mockTask,\n      dragPosition: { x: 100, y: 200 },\n      dropZone: {\n        date: new Date('2024-01-16'),\n        timeSlot: { hour: 14, minutes: 0 }\n      },\n      isValidDrop: true,\n      onDragEnd: jest.fn()\n    };\n\n    test('renders drag preview when dragging', () => {\n      render(<TaskDragPreview {...defaultProps} />);\n      \n      expect(screen.getByText('Test Task')).toBeInTheDocument();\n      \n      const preview = screen.getByText('Test Task').closest('.task-drag-preview');\n      expect(preview).toHaveStyle({\n        transform: 'translate(100px, 200px)'\n      });\n    });\n\n    test('shows drop zone indicator', () => {\n      render(<TaskDragPreview {...defaultProps} />);\n      \n      expect(screen.getByText(/drop here/i)).toBeInTheDocument();\n      expect(screen.getByText('January 16, 2:00 PM')).toBeInTheDocument();\n    });\n\n    test('indicates valid drop zone', () => {\n      render(<TaskDragPreview {...defaultProps} />);\n      \n      const dropIndicator = document.querySelector('.drop-zone-valid');\n      expect(dropIndicator).toBeInTheDocument();\n    });\n\n    test('indicates invalid drop zone', () => {\n      render(\n        <TaskDragPreview {...defaultProps} isValidDrop={false} />\n      );\n      \n      const dropIndicator = document.querySelector('.drop-zone-invalid');\n      expect(dropIndicator).toBeInTheDocument();\n    });\n\n    test('does not render when not dragging', () => {\n      render(\n        <TaskDragPreview {...defaultProps} draggedTask={null} />\n      );\n      \n      expect(screen.queryByText('Test Task')).not.toBeInTheDocument();\n    });\n\n    test('handles drag end', () => {\n      render(<TaskDragPreview {...defaultProps} />);\n      \n      // Simulate drag end\n      fireEvent.dragEnd(document.body);\n      \n      expect(defaultProps.onDragEnd).toHaveBeenCalled();\n    });\n  });\n\n  describe('useDragAndDrop Hook', () => {\n    const TestComponent = ({ onTaskDrop, validateDrop }) => {\n      const {\n        dragState,\n        handleDragStart,\n        handleDragOver,\n        handleDragLeave,\n        handleDrop,\n        handleDragEnd\n      } = useDragAndDrop({ onTaskDrop, validateDrop });\n\n      return (\n        <div>\n          <div\n            data-testid=\"draggable\"\n            draggable\n            onDragStart={(e) => handleDragStart(e, mockTask)}\n            onDragEnd={handleDragEnd}\n          >\n            Drag me\n          </div>\n          <div\n            data-testid=\"dropzone\"\n            onDragOver={(e) => handleDragOver(e, { date: new Date('2024-01-16') })}\n            onDragLeave={handleDragLeave}\n            onDrop={(e) => handleDrop(e, { date: new Date('2024-01-16') })}\n          >\n            Drop here\n          </div>\n          <div data-testid=\"drag-state\">\n            {JSON.stringify(dragState)}\n          </div>\n        </div>\n      );\n    };\n\n    test('handles drag start', () => {\n      const mockOnTaskDrop = jest.fn();\n      const mockValidateDrop = jest.fn(() => true);\n      \n      render(\n        <TestComponent \n          onTaskDrop={mockOnTaskDrop}\n          validateDrop={mockValidateDrop}\n        />\n      );\n      \n      const draggable = screen.getByTestId('draggable');\n      \n      fireEvent.dragStart(draggable, {\n        dataTransfer: {\n          setData: jest.fn(),\n          effectAllowed: ''\n        }\n      });\n      \n      const dragState = JSON.parse(screen.getByTestId('drag-state').textContent);\n      expect(dragState.isDragging).toBe(true);\n      expect(dragState.draggedTask).toEqual(mockTask);\n    });\n\n    test('handles drag over', () => {\n      const mockOnTaskDrop = jest.fn();\n      const mockValidateDrop = jest.fn(() => true);\n      \n      render(\n        <TestComponent \n          onTaskDrop={mockOnTaskDrop}\n          validateDrop={mockValidateDrop}\n        />\n      );\n      \n      const dropzone = screen.getByTestId('dropzone');\n      \n      fireEvent.dragOver(dropzone, {\n        preventDefault: jest.fn(),\n        dataTransfer: { dropEffect: '' }\n      });\n      \n      expect(mockValidateDrop).toHaveBeenCalled();\n    });\n\n    test('handles drop', () => {\n      const mockOnTaskDrop = jest.fn();\n      const mockValidateDrop = jest.fn(() => true);\n      \n      render(\n        <TestComponent \n          onTaskDrop={mockOnTaskDrop}\n          validateDrop={mockValidateDrop}\n        />\n      );\n      \n      const draggable = screen.getByTestId('draggable');\n      const dropzone = screen.getByTestId('dropzone');\n      \n      // Start drag\n      fireEvent.dragStart(draggable, {\n        dataTransfer: {\n          setData: jest.fn(),\n          effectAllowed: ''\n        }\n      });\n      \n      // Drop\n      fireEvent.drop(dropzone, {\n        preventDefault: jest.fn(),\n        dataTransfer: {\n          getData: jest.fn(() => JSON.stringify({\n            taskId: mockTask._id,\n            task: mockTask\n          }))\n        }\n      });\n      \n      expect(mockOnTaskDrop).toHaveBeenCalledWith(\n        mockTask,\n        expect.objectContaining({ date: expect.any(Date) }),\n        undefined\n      );\n    });\n\n    test('validates drop zones', () => {\n      const mockOnTaskDrop = jest.fn();\n      const mockValidateDrop = jest.fn(() => false);\n      \n      render(\n        <TestComponent \n          onTaskDrop={mockOnTaskDrop}\n          validateDrop={mockValidateDrop}\n        />\n      );\n      \n      const dropzone = screen.getByTestId('dropzone');\n      \n      fireEvent.dragOver(dropzone, {\n        preventDefault: jest.fn(),\n        dataTransfer: { dropEffect: '' }\n      });\n      \n      const dragState = JSON.parse(screen.getByTestId('drag-state').textContent);\n      expect(dragState.isValidDrop).toBe(false);\n    });\n\n    test('handles drag end', () => {\n      const mockOnTaskDrop = jest.fn();\n      const mockValidateDrop = jest.fn(() => true);\n      \n      render(\n        <TestComponent \n          onTaskDrop={mockOnTaskDrop}\n          validateDrop={mockValidateDrop}\n        />\n      );\n      \n      const draggable = screen.getByTestId('draggable');\n      \n      // Start drag\n      fireEvent.dragStart(draggable, {\n        dataTransfer: {\n          setData: jest.fn(),\n          effectAllowed: ''\n        }\n      });\n      \n      // End drag\n      fireEvent.dragEnd(draggable);\n      \n      const dragState = JSON.parse(screen.getByTestId('drag-state').textContent);\n      expect(dragState.isDragging).toBe(false);\n      expect(dragState.draggedTask).toBe(null);\n    });\n  });\n\n  describe('Integration Tests', () => {\n    test('task card integrates with drag and drop', () => {\n      const mockOnTaskDrop = jest.fn();\n      \n      render(\n        <DndTestWrapper>\n          <div>\n            <CalendarTaskCard\n              task={mockTask}\n              onClick={jest.fn()}\n              isDraggable={true}\n            />\n            <div\n              data-testid=\"calendar-cell\"\n              onDrop={(e) => {\n                e.preventDefault();\n                mockOnTaskDrop();\n              }}\n              onDragOver={(e) => e.preventDefault()}\n            >\n              Calendar Cell\n            </div>\n          </div>\n        </DndTestWrapper>\n      );\n      \n      const taskCard = screen.getByText('Test Task');\n      const calendarCell = screen.getByTestId('calendar-cell');\n      \n      // Simulate drag and drop\n      fireEvent.dragStart(taskCard);\n      fireEvent.dragOver(calendarCell);\n      fireEvent.drop(calendarCell);\n      \n      expect(mockOnTaskDrop).toHaveBeenCalled();\n    });\n\n    test('quick create integrates with calendar context', async () => {\n      const user = userEvent.setup();\n      const mockOnSubmit = jest.fn();\n      \n      render(\n        <TaskQuickCreate\n          isOpen={true}\n          onClose={jest.fn()}\n          onSubmit={mockOnSubmit}\n          selectedDate={new Date('2024-01-15')}\n        />\n      );\n      \n      // Create a task\n      await user.type(screen.getByLabelText(/title/i), 'Integration Test Task');\n      await user.click(screen.getByRole('button', { name: /create/i }));\n      \n      expect(mockOnSubmit).toHaveBeenCalledWith(\n        expect.objectContaining({\n          title: 'Integration Test Task',\n          due: expect.stringContaining('2024-01-15')\n        })\n      );\n    });\n\n    test('components handle error states gracefully', () => {\n      // Test with malformed task data\n      const malformedTask = {\n        _id: 'bad-task',\n        // Missing required fields\n      };\n      \n      expect(() => {\n        render(\n          <CalendarTaskCard\n            task={malformedTask}\n            onClick={jest.fn()}\n          />\n        );\n      }).not.toThrow();\n      \n      // Should show fallback content\n      expect(screen.getByText('Untitled Task')).toBeInTheDocument();\n    });\n  });\n\n  describe('Accessibility', () => {\n    test('task card has proper ARIA attributes', () => {\n      render(\n        <CalendarTaskCard\n          task={mockTask}\n          onClick={jest.fn()}\n        />\n      );\n      \n      const card = screen.getByText('Test Task').closest('.calendar-task-card');\n      expect(card).toHaveAttribute('role', 'button');\n      expect(card).toHaveAttribute('tabIndex', '0');\n    });\n\n    test('quick create modal has proper focus management', () => {\n      render(\n        <TaskQuickCreate\n          isOpen={true}\n          onClose={jest.fn()}\n          onSubmit={jest.fn()}\n        />\n      );\n      \n      // First focusable element should be focused\n      const titleInput = screen.getByLabelText(/title/i);\n      expect(document.activeElement).toBe(titleInput);\n    });\n\n    test('drag preview provides screen reader feedback', () => {\n      render(\n        <TaskDragPreview\n          draggedTask={mockTask}\n          dragPosition={{ x: 100, y: 200 }}\n          dropZone={{ date: new Date('2024-01-16') }}\n          isValidDrop={true}\n          onDragEnd={jest.fn()}\n        />\n      );\n      \n      const preview = document.querySelector('[aria-live]');\n      expect(preview).toBeInTheDocument();\n    });\n  });\n\n  describe('Performance', () => {\n    test('components render efficiently with many tasks', () => {\n      const manyTasks = Array.from({ length: 100 }, (_, i) => ({\n        ...mockTask,\n        _id: `task-${i}`,\n        title: `Task ${i}`\n      }));\n      \n      const startTime = performance.now();\n      \n      manyTasks.forEach((task, index) => {\n        const { unmount } = render(\n          <CalendarTaskCard\n            key={task._id}\n            task={task}\n            onClick={jest.fn()}\n          />\n        );\n        unmount();\n      });\n      \n      const endTime = performance.now();\n      const renderTime = endTime - startTime;\n      \n      // Should render efficiently\n      expect(renderTime).toBeLessThan(1000); // 1 second for 100 tasks\n    });\n\n    test('drag and drop handles rapid interactions', () => {\n      const mockOnTaskDrop = jest.fn();\n      const mockValidateDrop = jest.fn(() => true);\n      \n      const TestComponent = () => {\n        const { handleDragStart, handleDrop } = useDragAndDrop({\n          onTaskDrop: mockOnTaskDrop,\n          validateDrop: mockValidateDrop\n        });\n        \n        return (\n          <div>\n            <div\n              data-testid=\"draggable\"\n              onDragStart={(e) => handleDragStart(e, mockTask)}\n            >\n              Drag me\n            </div>\n            <div\n              data-testid=\"dropzone\"\n              onDrop={(e) => handleDrop(e, { date: new Date() })}\n            >\n              Drop here\n            </div>\n          </div>\n        );\n      };\n      \n      render(<TestComponent />);\n      \n      const draggable = screen.getByTestId('draggable');\n      const dropzone = screen.getByTestId('dropzone');\n      \n      // Rapid drag and drop operations\n      for (let i = 0; i < 10; i++) {\n        fireEvent.dragStart(draggable);\n        fireEvent.drop(dropzone, {\n          preventDefault: jest.fn(),\n          dataTransfer: {\n            getData: jest.fn(() => JSON.stringify({\n              taskId: mockTask._id,\n              task: mockTask\n            }))\n          }\n        });\n      }\n      \n      // Should handle all operations without errors\n      expect(mockOnTaskDrop).toHaveBeenCalledTimes(10);\n    });\n  });\n});