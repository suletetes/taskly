import {\n  createDefaultRecurringPattern,\n  validateRecurringPattern,\n  generateRecurringInstances,\n  getNextOccurrence,\n  isRecurringTask,\n  isRecurringInstance,\n  getRecurringSummary,\n  getRecurringInstancesInRange,\n  addRecurringException,\n  removeRecurringException,\n  getNextOccurrences,\n  RECURRING_TYPES,\n  END_TYPES\n} from '../../utils/recurringTaskUtils';\nimport { addDays, addWeeks, addMonths, format } from 'date-fns';\n\n// Mock task data\nconst createMockTask = (overrides = {}) => ({\n  _id: 'task-123',\n  title: 'Test Task',\n  description: 'Test Description',\n  due: new Date('2024-01-15T10:00:00Z').toISOString(),\n  priority: 'medium',\n  status: 'pending',\n  ...overrides\n});\n\ndescribe('Recurring Task Utils', () => {\n  describe('createDefaultRecurringPattern', () => {\n    test('creates default pattern with correct structure', () => {\n      const pattern = createDefaultRecurringPattern();\n      \n      expect(pattern).toEqual({\n        type: RECURRING_TYPES.NONE,\n        interval: 1,\n        daysOfWeek: [],\n        dayOfMonth: null,\n        monthOfYear: null,\n        endType: END_TYPES.NEVER,\n        endAfter: 10,\n        endOn: null,\n        exceptions: [],\n        timezone: expect.any(String)\n      });\n    });\n  });\n\n  describe('validateRecurringPattern', () => {\n    test('validates correct pattern', () => {\n      const pattern = {\n        type: RECURRING_TYPES.DAILY,\n        interval: 2,\n        endType: END_TYPES.NEVER\n      };\n      \n      const result = validateRecurringPattern(pattern);\n      expect(result.isValid).toBe(true);\n      expect(result.errors).toHaveLength(0);\n    });\n\n    test('rejects invalid type', () => {\n      const pattern = {\n        type: 'invalid-type',\n        interval: 1\n      };\n      \n      const result = validateRecurringPattern(pattern);\n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Invalid recurring type');\n    });\n\n    test('rejects invalid interval', () => {\n      const pattern = {\n        type: RECURRING_TYPES.DAILY,\n        interval: 0\n      };\n      \n      const result = validateRecurringPattern(pattern);\n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Interval must be between 1 and 365');\n    });\n\n    test('validates weekly pattern with days of week', () => {\n      const pattern = {\n        type: RECURRING_TYPES.WEEKLY,\n        interval: 1,\n        daysOfWeek: [1, 3, 5] // Mon, Wed, Fri\n      };\n      \n      const result = validateRecurringPattern(pattern);\n      expect(result.isValid).toBe(true);\n    });\n\n    test('rejects invalid days of week', () => {\n      const pattern = {\n        type: RECURRING_TYPES.WEEKLY,\n        interval: 1,\n        daysOfWeek: [1, 8] // 8 is invalid\n      };\n      \n      const result = validateRecurringPattern(pattern);\n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Invalid days of week');\n    });\n\n    test('validates end conditions', () => {\n      const pattern1 = {\n        type: RECURRING_TYPES.DAILY,\n        interval: 1,\n        endType: END_TYPES.AFTER,\n        endAfter: 5\n      };\n      \n      const result1 = validateRecurringPattern(pattern1);\n      expect(result1.isValid).toBe(true);\n      \n      const pattern2 = {\n        type: RECURRING_TYPES.DAILY,\n        interval: 1,\n        endType: END_TYPES.ON,\n        endOn: new Date('2024-12-31').toISOString()\n      };\n      \n      const result2 = validateRecurringPattern(pattern2);\n      expect(result2.isValid).toBe(true);\n    });\n  });\n\n  describe('generateRecurringInstances', () => {\n    test('generates daily recurring instances', () => {\n      const task = createMockTask();\n      const pattern = {\n        type: RECURRING_TYPES.DAILY,\n        interval: 1,\n        endType: END_TYPES.AFTER,\n        endAfter: 3\n      };\n      \n      const instances = generateRecurringInstances(task, pattern);\n      \n      expect(instances).toHaveLength(3);\n      expect(instances[0].due).toBe(task.due);\n      expect(instances[1].due).toBe(addDays(new Date(task.due), 1).toISOString());\n      expect(instances[2].due).toBe(addDays(new Date(task.due), 2).toISOString());\n    });\n\n    test('generates weekly recurring instances', () => {\n      const task = createMockTask();\n      const pattern = {\n        type: RECURRING_TYPES.WEEKLY,\n        interval: 1,\n        endType: END_TYPES.AFTER,\n        endAfter: 3\n      };\n      \n      const instances = generateRecurringInstances(task, pattern);\n      \n      expect(instances).toHaveLength(3);\n      expect(instances[1].due).toBe(addWeeks(new Date(task.due), 1).toISOString());\n      expect(instances[2].due).toBe(addWeeks(new Date(task.due), 2).toISOString());\n    });\n\n    test('generates monthly recurring instances', () => {\n      const task = createMockTask();\n      const pattern = {\n        type: RECURRING_TYPES.MONTHLY,\n        interval: 1,\n        endType: END_TYPES.AFTER,\n        endAfter: 3\n      };\n      \n      const instances = generateRecurringInstances(task, pattern);\n      \n      expect(instances).toHaveLength(3);\n      expect(instances[1].due).toBe(addMonths(new Date(task.due), 1).toISOString());\n      expect(instances[2].due).toBe(addMonths(new Date(task.due), 2).toISOString());\n    });\n\n    test('respects end date condition', () => {\n      const task = createMockTask();\n      const endDate = addDays(new Date(task.due), 5);\n      const pattern = {\n        type: RECURRING_TYPES.DAILY,\n        interval: 1,\n        endType: END_TYPES.ON,\n        endOn: endDate.toISOString()\n      };\n      \n      const instances = generateRecurringInstances(task, pattern);\n      \n      expect(instances.length).toBeLessThanOrEqual(6); // Should not exceed end date\n      instances.forEach(instance => {\n        expect(new Date(instance.due)).toBeLessThanOrEqual(endDate);\n      });\n    });\n\n    test('handles exceptions correctly', () => {\n      const task = createMockTask();\n      const exceptionDate = addDays(new Date(task.due), 1);\n      const pattern = {\n        type: RECURRING_TYPES.DAILY,\n        interval: 1,\n        endType: END_TYPES.AFTER,\n        endAfter: 5,\n        exceptions: [exceptionDate.toISOString()]\n      };\n      \n      const instances = generateRecurringInstances(task, pattern);\n      \n      // Should have 5 instances but skip the exception date\n      expect(instances).toHaveLength(5);\n      const instanceDates = instances.map(i => format(new Date(i.due), 'yyyy-MM-dd'));\n      expect(instanceDates).not.toContain(format(exceptionDate, 'yyyy-MM-dd'));\n    });\n\n    test('sets correct instance properties', () => {\n      const task = createMockTask();\n      const pattern = {\n        type: RECURRING_TYPES.DAILY,\n        interval: 1,\n        endType: END_TYPES.AFTER,\n        endAfter: 2\n      };\n      \n      const instances = generateRecurringInstances(task, pattern);\n      \n      expect(instances[0]).toMatchObject({\n        ...task,\n        isRecurring: true,\n        recurringId: task._id,\n        recurringPattern: pattern,\n        instanceNumber: 0,\n        originalDue: task.due\n      });\n      \n      expect(instances[1]).toMatchObject({\n        status: 'pending', // Should reset status for future instances\n        isRecurring: true,\n        instanceNumber: 1\n      });\n    });\n  });\n\n  describe('getNextOccurrence', () => {\n    const baseDate = new Date('2024-01-15T10:00:00Z');\n\n    test('calculates next daily occurrence', () => {\n      const pattern = { type: RECURRING_TYPES.DAILY, interval: 2 };\n      const next = getNextOccurrence(baseDate, pattern);\n      \n      expect(next).toEqual(addDays(baseDate, 2));\n    });\n\n    test('calculates next weekly occurrence', () => {\n      const pattern = { type: RECURRING_TYPES.WEEKLY, interval: 1 };\n      const next = getNextOccurrence(baseDate, pattern);\n      \n      expect(next).toEqual(addWeeks(baseDate, 1));\n    });\n\n    test('calculates next weekly occurrence with specific days', () => {\n      // Monday (baseDate is Monday, next should be Wednesday)\n      const pattern = {\n        type: RECURRING_TYPES.WEEKLY,\n        interval: 1,\n        daysOfWeek: [1, 3, 5] // Mon, Wed, Fri\n      };\n      \n      const next = getNextOccurrence(baseDate, pattern);\n      \n      // Should be Wednesday (2 days later)\n      expect(next).toEqual(addDays(baseDate, 2));\n    });\n\n    test('calculates next monthly occurrence', () => {\n      const pattern = { type: RECURRING_TYPES.MONTHLY, interval: 1 };\n      const next = getNextOccurrence(baseDate, pattern);\n      \n      expect(next).toEqual(addMonths(baseDate, 1));\n    });\n  });\n\n  describe('isRecurringTask', () => {\n    test('identifies recurring task', () => {\n      const task = {\n        recurring: { type: RECURRING_TYPES.DAILY }\n      };\n      \n      expect(isRecurringTask(task)).toBe(true);\n    });\n\n    test('identifies non-recurring task', () => {\n      const task = {\n        recurring: { type: RECURRING_TYPES.NONE }\n      };\n      \n      expect(isRecurringTask(task)).toBe(false);\n    });\n\n    test('handles task without recurring property', () => {\n      const task = {};\n      \n      expect(isRecurringTask(task)).toBe(false);\n    });\n  });\n\n  describe('isRecurringInstance', () => {\n    test('identifies recurring instance', () => {\n      const task = { isRecurring: true };\n      \n      expect(isRecurringInstance(task)).toBe(true);\n    });\n\n    test('identifies task with recurringId', () => {\n      const task = { recurringId: 'parent-task-id' };\n      \n      expect(isRecurringInstance(task)).toBe(true);\n    });\n\n    test('identifies non-recurring instance', () => {\n      const task = {};\n      \n      expect(isRecurringInstance(task)).toBe(false);\n    });\n  });\n\n  describe('getRecurringSummary', () => {\n    test('returns summary for daily pattern', () => {\n      const pattern = {\n        type: RECURRING_TYPES.DAILY,\n        interval: 1,\n        endType: END_TYPES.NEVER\n      };\n      \n      expect(getRecurringSummary(pattern)).toBe('Daily');\n    });\n\n    test('returns summary for weekly pattern with days', () => {\n      const pattern = {\n        type: RECURRING_TYPES.WEEKLY,\n        interval: 1,\n        daysOfWeek: [1, 3, 5],\n        endType: END_TYPES.NEVER\n      };\n      \n      expect(getRecurringSummary(pattern)).toBe('Weekly on Mon, Tue, Wed');\n    });\n\n    test('returns summary with end condition', () => {\n      const pattern = {\n        type: RECURRING_TYPES.DAILY,\n        interval: 1,\n        endType: END_TYPES.AFTER,\n        endAfter: 10\n      };\n      \n      expect(getRecurringSummary(pattern)).toBe('Daily, 10 times');\n    });\n\n    test('returns summary for non-recurring', () => {\n      const pattern = { type: RECURRING_TYPES.NONE };\n      \n      expect(getRecurringSummary(pattern)).toBe('Does not repeat');\n    });\n  });\n\n  describe('getRecurringInstancesInRange', () => {\n    test('returns instances within date range', () => {\n      const recurringTask = createMockTask({\n        recurring: {\n          type: RECURRING_TYPES.DAILY,\n          interval: 1,\n          endType: END_TYPES.NEVER\n        }\n      });\n      \n      const nonRecurringTask = createMockTask({\n        _id: 'task-456',\n        due: addDays(new Date(recurringTask.due), 2).toISOString()\n      });\n      \n      const tasks = [recurringTask, nonRecurringTask];\n      const startDate = new Date(recurringTask.due);\n      const endDate = addDays(startDate, 5);\n      \n      const instances = getRecurringInstancesInRange(tasks, startDate, endDate);\n      \n      expect(instances.length).toBeGreaterThan(1);\n      \n      // Should include both recurring instances and non-recurring task\n      const taskIds = instances.map(i => i._id || i.id);\n      expect(taskIds).toContain('task-456');\n    });\n\n    test('filters out instances outside range', () => {\n      const task = createMockTask({\n        recurring: {\n          type: RECURRING_TYPES.DAILY,\n          interval: 1,\n          endType: END_TYPES.NEVER\n        }\n      });\n      \n      const startDate = addDays(new Date(task.due), 10);\n      const endDate = addDays(startDate, 2);\n      \n      const instances = getRecurringInstancesInRange([task], startDate, endDate);\n      \n      instances.forEach(instance => {\n        const instanceDate = new Date(instance.due);\n        expect(instanceDate).toBeGreaterThanOrEqual(startDate);\n        expect(instanceDate).toBeLessThanOrEqual(endDate);\n      });\n    });\n  });\n\n  describe('addRecurringException', () => {\n    test('adds exception date to pattern', () => {\n      const pattern = {\n        type: RECURRING_TYPES.DAILY,\n        exceptions: []\n      };\n      \n      const exceptionDate = new Date('2024-01-20');\n      const updatedPattern = addRecurringException(pattern, exceptionDate);\n      \n      expect(updatedPattern.exceptions).toContain(exceptionDate.toISOString());\n    });\n\n    test('does not add duplicate exceptions', () => {\n      const exceptionDate = new Date('2024-01-20');\n      const pattern = {\n        type: RECURRING_TYPES.DAILY,\n        exceptions: [exceptionDate.toISOString()]\n      };\n      \n      const updatedPattern = addRecurringException(pattern, exceptionDate);\n      \n      expect(updatedPattern.exceptions).toHaveLength(1);\n    });\n  });\n\n  describe('removeRecurringException', () => {\n    test('removes exception date from pattern', () => {\n      const exceptionDate = new Date('2024-01-20');\n      const pattern = {\n        type: RECURRING_TYPES.DAILY,\n        exceptions: [exceptionDate.toISOString()]\n      };\n      \n      const updatedPattern = removeRecurringException(pattern, exceptionDate);\n      \n      expect(updatedPattern.exceptions).not.toContain(exceptionDate.toISOString());\n    });\n  });\n\n  describe('getNextOccurrences', () => {\n    test('returns next few occurrences for preview', () => {\n      const task = createMockTask();\n      const pattern = {\n        type: RECURRING_TYPES.DAILY,\n        interval: 1,\n        endType: END_TYPES.NEVER\n      };\n      \n      const occurrences = getNextOccurrences(task, pattern, 3);\n      \n      expect(occurrences).toHaveLength(3);\n      expect(occurrences[0]).toMatchObject({\n        date: new Date(task.due),\n        title: task.title,\n        priority: task.priority\n      });\n    });\n\n    test('returns empty array for non-recurring task', () => {\n      const task = createMockTask();\n      const pattern = { type: RECURRING_TYPES.NONE };\n      \n      const occurrences = getNextOccurrences(task, pattern);\n      \n      expect(occurrences).toHaveLength(0);\n    });\n  });\n\n  describe('Edge Cases', () => {\n    test('handles leap year correctly', () => {\n      const task = createMockTask({\n        due: new Date('2024-02-29T10:00:00Z').toISOString() // Leap year\n      });\n      \n      const pattern = {\n        type: RECURRING_TYPES.YEARLY,\n        interval: 1,\n        endType: END_TYPES.AFTER,\n        endAfter: 2\n      };\n      \n      const instances = generateRecurringInstances(task, pattern);\n      \n      expect(instances).toHaveLength(2);\n      // Next year (2025) should handle Feb 29 -> Feb 28\n      expect(instances[1].due).toBe(new Date('2025-02-28T10:00:00Z').toISOString());\n    });\n\n    test('handles end of month correctly for monthly recurrence', () => {\n      const task = createMockTask({\n        due: new Date('2024-01-31T10:00:00Z').toISOString()\n      });\n      \n      const pattern = {\n        type: RECURRING_TYPES.MONTHLY,\n        interval: 1,\n        dayOfMonth: 31,\n        endType: END_TYPES.AFTER,\n        endAfter: 3\n      };\n      \n      const instances = generateRecurringInstances(task, pattern);\n      \n      expect(instances).toHaveLength(3);\n      // February should use Feb 29 (2024 is leap year)\n      expect(instances[1].due).toBe(new Date('2024-02-29T10:00:00Z').toISOString());\n    });\n\n    test('prevents infinite loops with safety limit', () => {\n      const task = createMockTask();\n      const pattern = {\n        type: RECURRING_TYPES.DAILY,\n        interval: 1,\n        endType: END_TYPES.NEVER // This could cause infinite loop\n      };\n      \n      const instances = generateRecurringInstances(task, pattern, {\n        maxInstances: 2000 // Set high limit to test safety\n      });\n      \n      // Should be limited to prevent infinite loops\n      expect(instances.length).toBeLessThanOrEqual(1000);\n    });\n  });\n});