import { renderHook, act } from '@testing-library/react';\nimport { performance } from 'perf_hooks';\nimport { addDays, startOfMonth, endOfMonth } from 'date-fns';\n\n// Import hooks and utilities to test\nimport { useCalendarOptimization } from '../../hooks/useCalendarOptimization';\nimport calendarDataLoader from '../../utils/calendarDataLoader';\nimport { generateRecurringInstances } from '../../utils/recurringTaskUtils';\n\n// Mock data generators\nconst generateMockTasks = (count, startDate = new Date()) => {\n  return Array.from({ length: count }, (_, i) => ({\n    _id: `task-${i}`,\n    title: `Task ${i}`,\n    description: `Description for task ${i}`,\n    due: addDays(startDate, i % 30).toISOString(),\n    priority: ['low', 'medium', 'high'][i % 3],\n    status: ['pending', 'in-progress', 'completed'][i % 3],\n    tags: [`tag${i % 5}`, `category${i % 3}`],\n    project: {\n      _id: `project-${i % 10}`,\n      name: `Project ${i % 10}`\n    }\n  }));\n};\n\nconst generateLargeTaskSet = (count = 10000) => {\n  return generateMockTasks(count);\n};\n\ndescribe('Calendar Performance Tests', () => {\n  beforeEach(() => {\n    // Clear any existing cache\n    calendarDataLoader.clearCache();\n  });\n\n  describe('useCalendarOptimization Hook', () => {\n    test('handles large task sets efficiently', () => {\n      const largeTasks = generateLargeTaskSet(5000);\n      const currentDate = new Date();\n      const filters = {};\n      \n      const startTime = performance.now();\n      \n      const { result } = renderHook(() => \n        useCalendarOptimization({\n          tasks: largeTasks,\n          currentDate,\n          currentView: 'month',\n          filters\n        })\n      );\n      \n      const endTime = performance.now();\n      const initTime = endTime - startTime;\n      \n      // Should initialize within reasonable time\n      expect(initTime).toBeLessThan(1000); // 1 second\n      expect(result.current.visibleTasks).toBeDefined();\n      expect(result.current.taskIndex).toBeDefined();\n    });\n\n    test('filters tasks efficiently with large datasets', () => {\n      const largeTasks = generateLargeTaskSet(10000);\n      const currentDate = new Date();\n      \n      const { result } = renderHook(() => \n        useCalendarOptimization({\n          tasks: largeTasks,\n          currentDate,\n          currentView: 'month',\n          filters: { priority: ['high'], status: ['pending'] }\n        })\n      );\n      \n      const startTime = performance.now();\n      \n      act(() => {\n        // Trigger filtering\n        result.current.getFilteredTasks('month', currentDate, {\n          priority: ['high'],\n          status: ['pending']\n        });\n      });\n      \n      const endTime = performance.now();\n      const filterTime = endTime - startTime;\n      \n      // Filtering should be fast even with large datasets\n      expect(filterTime).toBeLessThan(100); // 100ms\n    });\n\n    test('memoization prevents unnecessary recalculations', () => {\n      const tasks = generateMockTasks(1000);\n      const currentDate = new Date();\n      \n      const { result, rerender } = renderHook(\n        ({ tasks, currentDate, filters }) => \n          useCalendarOptimization({\n            tasks,\n            currentDate,\n            currentView: 'month',\n            filters\n          }),\n        {\n          initialProps: {\n            tasks,\n            currentDate,\n            filters: { priority: ['high'] }\n          }\n        }\n      );\n      \n      const firstResult = result.current.visibleTasks;\n      \n      // Rerender with same props\n      rerender({\n        tasks,\n        currentDate,\n        filters: { priority: ['high'] }\n      });\n      \n      const secondResult = result.current.visibleTasks;\n      \n      // Should return the same reference (memoized)\n      expect(firstResult).toBe(secondResult);\n    });\n\n    test('virtual scrolling handles large lists', () => {\n      const largeTasks = generateLargeTaskSet(10000);\n      \n      const { result } = renderHook(() => \n        useCalendarOptimization({\n          tasks: largeTasks,\n          currentDate: new Date(),\n          currentView: 'agenda',\n          filters: {}\n        })\n      );\n      \n      const virtualScrolling = result.current.useVirtualScrolling({\n        items: largeTasks,\n        itemHeight: 60,\n        containerHeight: 400\n      });\n      \n      // Should only render visible items\n      expect(virtualScrolling.visibleRange.visibleItems.length).toBeLessThan(50);\n      expect(virtualScrolling.totalHeight).toBe(largeTasks.length * 60);\n    });\n\n    test('task grouping is efficient', () => {\n      const largeTasks = generateLargeTaskSet(5000);\n      \n      const { result } = renderHook(() => \n        useCalendarOptimization({\n          tasks: largeTasks,\n          currentDate: new Date(),\n          currentView: 'month',\n          filters: {}\n        })\n      );\n      \n      const startTime = performance.now();\n      \n      const groupedByDate = result.current.getGroupedTasks(largeTasks, 'date');\n      const groupedByPriority = result.current.getGroupedTasks(largeTasks, 'priority');\n      \n      const endTime = performance.now();\n      const groupingTime = endTime - startTime;\n      \n      expect(groupingTime).toBeLessThan(100); // Should be fast\n      expect(groupedByDate.size).toBeGreaterThan(0);\n      expect(groupedByPriority.size).toBe(3); // low, medium, high\n    });\n  });\n\n  describe('Calendar Data Loader Performance', () => {\n    const mockLoadTasksFn = jest.fn().mockImplementation((start, end) => {\n      const tasks = generateMockTasks(100, start);\n      return Promise.resolve(tasks);\n    });\n\n    beforeEach(() => {\n      mockLoadTasksFn.mockClear();\n    });\n\n    test('caching prevents redundant API calls', async () => {\n      const startDate = startOfMonth(new Date());\n      const endDate = endOfMonth(new Date());\n      \n      // First call\n      await calendarDataLoader.loadTasks(startDate, endDate, {}, {\n        loadTasksFn: mockLoadTasksFn\n      });\n      \n      // Second call with same parameters\n      await calendarDataLoader.loadTasks(startDate, endDate, {}, {\n        loadTasksFn: mockLoadTasksFn\n      });\n      \n      // Should only call the function once due to caching\n      expect(mockLoadTasksFn).toHaveBeenCalledTimes(1);\n    });\n\n    test('batch loading handles large date ranges efficiently', async () => {\n      const startDate = new Date('2024-01-01');\n      const endDate = new Date('2024-12-31'); // Full year\n      \n      const startTime = performance.now();\n      \n      const result = await calendarDataLoader.loadTasks(startDate, endDate, {}, {\n        loadTasksFn: mockLoadTasksFn\n      });\n      \n      const endTime = performance.now();\n      const loadTime = endTime - startTime;\n      \n      expect(loadTime).toBeLessThan(2000); // Should complete within 2 seconds\n      expect(result.tasks).toBeDefined();\n      expect(mockLoadTasksFn).toHaveBeenCalled();\n    });\n\n    test('LRU cache eviction works correctly', async () => {\n      const loader = calendarDataLoader;\n      \n      // Fill cache beyond max size\n      const promises = [];\n      for (let i = 0; i < 60; i++) { // Exceed default max cache size of 50\n        const start = addDays(new Date(), i);\n        const end = addDays(start, 1);\n        promises.push(\n          loader.loadTasks(start, end, {}, { loadTasksFn: mockLoadTasksFn })\n        );\n      }\n      \n      await Promise.all(promises);\n      \n      const stats = loader.getCacheStats();\n      expect(stats.size).toBeLessThanOrEqual(50); // Should not exceed max size\n    });\n\n    test('prefetching improves perceived performance', async () => {\n      const currentDate = new Date();\n      \n      // Start prefetching\n      calendarDataLoader.prefetchAdjacent(\n        currentDate,\n        'month',\n        {},\n        mockLoadTasksFn\n      );\n      \n      // Wait a bit for prefetch to start\n      await new Promise(resolve => setTimeout(resolve, 200));\n      \n      // Request adjacent month (should be prefetched)\n      const nextMonth = addDays(currentDate, 32);\n      const startTime = performance.now();\n      \n      await calendarDataLoader.loadTasks(\n        startOfMonth(nextMonth),\n        endOfMonth(nextMonth),\n        {},\n        { loadTasksFn: mockLoadTasksFn }\n      );\n      \n      const endTime = performance.now();\n      const loadTime = endTime - startTime;\n      \n      // Should be very fast due to prefetching\n      expect(loadTime).toBeLessThan(50);\n    });\n  });\n\n  describe('Recurring Task Performance', () => {\n    test('generates large numbers of recurring instances efficiently', () => {\n      const baseTask = {\n        _id: 'recurring-task',\n        title: 'Daily Standup',\n        due: new Date().toISOString(),\n        priority: 'medium',\n        status: 'pending'\n      };\n      \n      const pattern = {\n        type: 'daily',\n        interval: 1,\n        endType: 'after',\n        endAfter: 1000 // Generate 1000 instances\n      };\n      \n      const startTime = performance.now();\n      \n      const instances = generateRecurringInstances(baseTask, pattern);\n      \n      const endTime = performance.now();\n      const generateTime = endTime - startTime;\n      \n      expect(generateTime).toBeLessThan(500); // Should be fast\n      expect(instances).toHaveLength(1000);\n    });\n\n    test('complex recurring patterns perform well', () => {\n      const baseTask = {\n        _id: 'complex-recurring',\n        title: 'Weekly Team Meeting',\n        due: new Date().toISOString(),\n        priority: 'high',\n        status: 'pending'\n      };\n      \n      const pattern = {\n        type: 'weekly',\n        interval: 1,\n        daysOfWeek: [1, 3, 5], // Mon, Wed, Fri\n        endType: 'after',\n        endAfter: 500,\n        exceptions: [\n          addDays(new Date(), 7).toISOString(),\n          addDays(new Date(), 14).toISOString()\n        ]\n      };\n      \n      const startTime = performance.now();\n      \n      const instances = generateRecurringInstances(baseTask, pattern);\n      \n      const endTime = performance.now();\n      const generateTime = endTime - startTime;\n      \n      expect(generateTime).toBeLessThan(1000);\n      expect(instances.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Memory Usage', () => {\n    test('memory usage stays within reasonable bounds', () => {\n      const largeTasks = generateLargeTaskSet(10000);\n      \n      // Measure initial memory\n      const initialMemory = process.memoryUsage();\n      \n      const { result } = renderHook(() => \n        useCalendarOptimization({\n          tasks: largeTasks,\n          currentDate: new Date(),\n          currentView: 'month',\n          filters: {}\n        })\n      );\n      \n      // Force some operations\n      act(() => {\n        result.current.getFilteredTasks('month', new Date(), {});\n        result.current.getGroupedTasks(largeTasks, 'date');\n      });\n      \n      const finalMemory = process.memoryUsage();\n      const memoryIncrease = finalMemory.heapUsed - initialMemory.heapUsed;\n      \n      // Memory increase should be reasonable (less than 100MB)\n      expect(memoryIncrease).toBeLessThan(100 * 1024 * 1024);\n    });\n\n    test('cache memory usage is tracked correctly', () => {\n      const loader = calendarDataLoader;\n      \n      const memoryUsage = loader.getMemoryUsage();\n      \n      expect(memoryUsage).toHaveProperty('estimatedBytes');\n      expect(memoryUsage).toHaveProperty('estimatedMB');\n      expect(memoryUsage).toHaveProperty('entries');\n      expect(memoryUsage.estimatedBytes).toBeGreaterThanOrEqual(0);\n    });\n  });\n\n  describe('Rendering Performance', () => {\n    test('calendar grid renders large datasets efficiently', () => {\n      // This would typically be tested with actual React components\n      // For now, we'll test the data preparation performance\n      \n      const largeTasks = generateLargeTaskSet(5000);\n      const dates = Array.from({ length: 42 }, (_, i) => addDays(new Date(), i));\n      \n      const startTime = performance.now();\n      \n      // Simulate task positioning calculations\n      const tasksByDate = new Map();\n      largeTasks.forEach(task => {\n        if (!task.due) return;\n        \n        const dateKey = task.due.split('T')[0];\n        if (!tasksByDate.has(dateKey)) {\n          tasksByDate.set(dateKey, []);\n        }\n        tasksByDate.get(dateKey).push(task);\n      });\n      \n      const endTime = performance.now();\n      const processingTime = endTime - startTime;\n      \n      expect(processingTime).toBeLessThan(100);\n      expect(tasksByDate.size).toBeGreaterThan(0);\n    });\n\n    test('task overlap detection is efficient', () => {\n      const tasksOnSameDay = Array.from({ length: 50 }, (_, i) => ({\n        _id: `task-${i}`,\n        title: `Task ${i}`,\n        due: new Date().toISOString(),\n        priority: 'medium',\n        status: 'pending'\n      }));\n      \n      const startTime = performance.now();\n      \n      // Simulate overlap detection\n      const positions = tasksOnSameDay.map((task, index) => ({\n        task,\n        x: 0,\n        y: index * 25,\n        width: 150,\n        height: 20\n      }));\n      \n      // Simple overlap detection\n      positions.forEach((position, index) => {\n        const overlaps = positions.slice(0, index).filter(other => \n          position.y < other.y + other.height &&\n          position.y + position.height > other.y\n        );\n        position.overlaps = overlaps.length;\n      });\n      \n      const endTime = performance.now();\n      const detectionTime = endTime - startTime;\n      \n      expect(detectionTime).toBeLessThan(50);\n      expect(positions).toHaveLength(50);\n    });\n  });\n\n  describe('Performance Monitoring', () => {\n    test('performance metrics are collected correctly', () => {\n      const { result } = renderHook(() => \n        useCalendarOptimization({\n          tasks: generateMockTasks(100),\n          currentDate: new Date(),\n          currentView: 'month',\n          filters: {}\n        })\n      );\n      \n      const metrics = result.current.getPerformanceMetrics();\n      \n      expect(metrics).toHaveProperty('lastComputeTime');\n      expect(metrics).toHaveProperty('cacheSize');\n      expect(metrics).toHaveProperty('indexSize');\n      expect(metrics).toHaveProperty('taskCount');\n      \n      expect(typeof metrics.lastComputeTime).toBe('number');\n      expect(typeof metrics.cacheSize).toBe('number');\n      expect(typeof metrics.indexSize).toBe('number');\n      expect(typeof metrics.taskCount).toBe('number');\n    });\n\n    test('slow operations are detected', () => {\n      const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();\n      \n      // Simulate slow operation\n      const slowFunction = () => {\n        const start = Date.now();\n        while (Date.now() - start < 100) {\n          // Busy wait to simulate slow operation\n        }\n      };\n      \n      const startTime = performance.now();\n      slowFunction();\n      const endTime = performance.now();\n      \n      const duration = endTime - startTime;\n      \n      if (duration > 16) { // More than one frame at 60fps\n        console.warn(`Slow operation detected: ${duration.toFixed(2)}ms`);\n      }\n      \n      expect(duration).toBeGreaterThan(16);\n      expect(consoleSpy).toHaveBeenCalled();\n      \n      consoleSpy.mockRestore();\n    });\n  });\n\n  describe('Stress Tests', () => {\n    test('handles extreme task counts', () => {\n      const extremeTasks = generateLargeTaskSet(50000);\n      \n      const startTime = performance.now();\n      \n      const { result } = renderHook(() => \n        useCalendarOptimization({\n          tasks: extremeTasks,\n          currentDate: new Date(),\n          currentView: 'month',\n          filters: {}\n        })\n      );\n      \n      const endTime = performance.now();\n      const initTime = endTime - startTime;\n      \n      // Should handle even extreme cases within reasonable time\n      expect(initTime).toBeLessThan(5000); // 5 seconds\n      expect(result.current.visibleTasks).toBeDefined();\n    });\n\n    test('handles rapid filter changes', () => {\n      const tasks = generateMockTasks(1000);\n      \n      const { result } = renderHook(() => \n        useCalendarOptimization({\n          tasks,\n          currentDate: new Date(),\n          currentView: 'month',\n          filters: { priority: ['high'] }\n        })\n      );\n      \n      const startTime = performance.now();\n      \n      // Simulate rapid filter changes\n      const filters = [\n        { priority: ['high'] },\n        { priority: ['medium'] },\n        { priority: ['low'] },\n        { status: ['pending'] },\n        { status: ['completed'] },\n        { priority: ['high'], status: ['pending'] }\n      ];\n      \n      filters.forEach(filter => {\n        act(() => {\n          result.current.getFilteredTasks('month', new Date(), filter);\n        });\n      });\n      \n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      \n      // Should handle rapid changes efficiently\n      expect(totalTime).toBeLessThan(500);\n    });\n  });\n});